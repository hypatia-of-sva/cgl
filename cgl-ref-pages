Common OpenGL Subset Documentation

Documentation of the common OpenGL subset. This includes the intersection of the OpenGL 2.1, OpenGL ES 2.0 and OpenGL 4 Reference Pages by Khronos, and describes therefore a commonly usable GL API.





glActiveTexture — select active texture unit
    void glActiveTexture(GLenum texture);

texture:
    Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.

glActiveTexture selects which texture unit subsequent texture state calls will affect. The number of texture units an implementation supports is implementation dependent, but must be at least 2 as per GL 2.1.

errors:
    GL_INVALID_ENUM is generated if
        - texture is not one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS-1).

associated gets:
    glGet with argument GL_ACTIVE_TEXTURE or GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS





glAttachShader — attach a shader object to a program object
    void glAttachShader(GLuint program, GLuint shader);

program:
    Specifies the program object to which a shader object will be attached.
shader:
    Specifies the shader object that is to be attached.

In order to create an executable/a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. glAttachShader attaches the shader object specified by shader to the program object specified by program. This indicates that shader will be included in link operations that will be performed on program.

All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. Multiple shader objects of the same type may not be attached to a single program object as per GL ES 2.9. However, a single shader object may be attached to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until glDetachShader is called to detach it from all program objects to which it is attached.

errors:
    GL_INVALID_VALUE is generated if
        - either program or shader is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - shader is not a shader object.
        - shader is already attached to program, or
        - (in ES 2.0 only) another shader object of the same type as shader is already attached to program.

associated gets:
    glGetAttachedShaders with the handle of a valid program object
    glIsProgram
    glIsShader








glBindAttribLocation — associate a generic vertex attribute index with a named attribute variable
    void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);

program:
    Specifies the handle of the program object in which the association is to be made.
index:
    Specifies the index of the generic vertex attribute to be bound.
name:
    Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.

glBindAttribLocation is used to associate a user-defined attribute variable in the program object specified by program with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in name. The generic vertex attribute index to be bound to this variable is specified by index. When program is made part of current state, values provided via the generic vertex attribute index will modify the value of the user-defined attribute variable specified by name.

If name refers to a matrix attribute variable, index refers to the first column of the matrix. Other matrix columns are then automatically bound to locations index+1 for a matrix of type mat2; index+1 and index+2 for a matrix of type mat3; and index+1, index+2, and index+3 for a matrix of type mat4.

This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from 0 to GL_MAX_VERTEX_ATTRIBS -1. The values sent to each generic attribute index are part of current state, (just like standard vertex attributes such as color, normal, and vertex position)[omitted in GL4]. If a different program object is made current by calling glUseProgram, the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to index.

Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling glBindAttribLocation. Attribute bindings do not go into effect until glLinkProgram is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs.

(Applications are not allowed to bind any of the standard OpenGL vertex attributes using this command, as they are bound automatically when needed.)[omitted in GL4] Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.


Notes

glBindAttribLocation can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.

If name was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index.

Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called aliasing, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing. (Because there is no way to bind standard attributes, it is not possible to alias generic attributes with conventional ones (except for generic attribute 0).)[omitted in GL4]

Active attributes that are not explicitly bound will be bound by the linker when glLinkProgram is called. The locations assigned can be queried by calling glGetAttribLocation.

OpenGL copies the name string when glBindAttribLocation is called, so an application may free its copy of the name string immediately after the function returns.

errors:
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - name starts with the reserved prefix "gl_".
        - program is not a program object.

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS
    glGetActiveAttrib with argument program
    glGetAttribLocation with arguments program and name
    glIsProgram











glBindBuffer — bind a named buffer object
    void glBindBuffer(GLenum target, GLuint buffer);

target:
    Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER [purpose: Vertex attributes, according to GL4] or GL_ELEMENT_ARRAY_BUFFER [purpose: Vertex array indices, according to GL4]. Limitation as per GL ES 2.0.
buffer:
    Specifies the name of a buffer object.

glBindBuffer lets you create or use a named buffer object. Calling glBindBuffer with target set to GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER and buffer set to the name of the new buffer object binds the buffer object name to the target. (If no buffer object with name buffer exists, one is created with that name.)[GL4 only] When a buffer object is bound to a target, the previous binding for that target is automatically broken.

Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target ((if supported for that target))[GL 4 only]. Buffer object names and the corresponding buffer object contents are local to the shared (object space)[as per ES 2.0 and GL4]/(display-list space (see glXCreateContext))[as per GL 2.1] of the current GL rendering context(; two rendering contexts share buffer object names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in ES 2.0]

(You may use glGenBuffers to generate a set of new buffer object names.)[GL ES 2.0, GL 2.1]/(glGenBuffers must be used to generate a set of unused buffer object names.)[GL 4]

The state of a buffer object immediately after it is first bound is a[n] (unmapped)[omitted in GL ES 2.0] zero-sized memory buffer with (GL_READ_WRITE access and)[omitted in GL ES 2.0] GL_STATIC_DRAW usage.

While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an GL_INVALID_OPERATION error.

When vertex array pointer state is changed (by a call to glVertexAttribPointer)[ES 2.0]/(for example by a call to glNormalPointer)[GL 2.1], the current buffer object binding (GL_ARRAY_BUFFER_BINDING) is copied into the corresponding client state for (the vertex attrib array being changed, one of the indexed GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDINGs)[ES 2.0]/(vertex array type being changed, for example GL_NORMAL_ARRAY_BUFFER_BINDING.)[GL 2.1]. While a non-zero buffer object is bound to the GL_ARRAY_BUFFER target, the vertex array pointer parameter (that is traditionally interpreted as a pointer to client-side memory)[omited in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, the indices parameter of glDrawElements (that is traditionally interpreted as a pointer to client-side memory)[omitted in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

A buffer object binding created with glBindBuffer remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with glDeleteBuffers.

Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - buffer is not a name previously returned from a call to glGenBuffers. [GL 4 only]

associated gets:
    glGet with argument GL_ARRAY_BUFFER_BINDING
    glGet with argument GL_ELEMENT_ARRAY_BUFFER_BINDING












glBindTexture — bind a named texture to a texturing target
    void glBindTexture(GLenum target, GLuint texture);

target:
    Specifies the target (of the active texture unit)[only GL ES 2.0] to which the texture is bound. Must be either GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP. Limitation as per GL ES 2.0
texture:
    Specifies the name of a texture.

glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP and texture set to the name of the new texture binds the texture name to the target (of the current active texture unit)[GL ES 2.0 only]. When a texture is bound to a target, the previous binding for that target is automatically broken.

Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared (object space)[GL ES 2.0, GL 4]/(display-list space (see glXCreateContext))[GL 2.1] of the current GL rendering context(; two rendering contexts share texture names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in GL ES 2.0].

You (may)[GL 2.1, ES 2.0]/(must)[GL 4] use glGenTextures to generate a set of new texture names.

When a texture is first bound, it assumes the specified target: A texture first bound to GL_TEXTURE_2D becomes a two-dimensional texture and a texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped texture. The state of a two-dimensional texture immediately after it is first bound is equivalent to the state of the default GL_TEXTURE_2D at GL initialization, and similarly for cube-mapped textures.

While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. (If texture mapping is active on the target to which a texture is bound, the bound texture is used.)[GL 2.1 only] In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.

A texture binding created with glBindTexture remains active until a different texture is bound to the same target, or until the bound texture is deleted with glDeleteTextures.

Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use glBindTexture to bind an existing named texture to one of the texture targets than it is to reload the texture image using glTexImage2D. (For additional control over performance, use glPrioritizeTextures. glBindTexture is included in display lists. )[GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - texture is not a name returned from a previous call to glGenTextures.  [GL 4 only]
    GL_INVALID_OPERATION is generated if
        - texture was previously created with a target that doesn't match that of target.

associated gets:
    glGet with argument GL_TEXTURE_BINDING_2D or GL_TEXTURE_BINDING_CUBE_MAP







glBlendColor — set the blend color
    void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); [GL ES 2.0, GL 2.1]
    void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); [GL 4]

red, green, blue, alpha:
    specify the components of GL_BLEND_COLOR

The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The color components are clamped to the range [0, 1] before being stored. See glBlendFunc for a complete description of the blending operations. Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0).

Notes:

glBlendColor is part of the ARB_imaging subset. glBlendColor is present only if ARB_imaging is returned when glGetString is called with GL_EXTENSIONS as its argument. [GL 2.1 only]

The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

assigned gets:
    glGet with an argument of GL_BLEND_COLOR






glBlendEquation — specify the equation used for both the RGB blend equation and the Alpha blend equation
    void glBlendEquation(GLenum mode);

mode:
    specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT. Limitation as per GL ES 2.0

The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation.

These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA




glBlendEquationSeparate — set the RGB blend equation and the alpha blend equation separately
    void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);

modeRGB:
    specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.
modeAlpha:
    specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function specifies one blend equation for the RGB-color components and one blend equation for the alpha component.

The blend equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA




