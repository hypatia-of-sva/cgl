Common OpenGL Subset Documentation

Documentation of the common OpenGL subset. This includes the intersection of the OpenGL 2.1, OpenGL ES 2.0 and OpenGL 4 Reference Pages by Khronos, and describes therefore a commonly usable GL API.





glActiveTexture — select active texture unit
    void glActiveTexture(GLenum texture);

texture:
    Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.

glActiveTexture selects which texture unit subsequent texture state calls will affect. The number of texture units an implementation supports is implementation dependent, but must be at least 2 as per GL 2.1.

errors:
    GL_INVALID_ENUM is generated if
        - texture is not one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS-1).

associated gets:
    glGet with argument GL_ACTIVE_TEXTURE or GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS





glAttachShader — attach a shader object to a program object
    void glAttachShader(GLuint program, GLuint shader);

program:
    Specifies the program object to which a shader object will be attached.
shader:
    Specifies the shader object that is to be attached.

In order to create an executable/a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. glAttachShader attaches the shader object specified by shader to the program object specified by program. This indicates that shader will be included in link operations that will be performed on program.

All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. Multiple shader objects of the same type may not be attached to a single program object as per GL ES 2.9. However, a single shader object may be attached to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until glDetachShader is called to detach it from all program objects to which it is attached.

errors:
    GL_INVALID_VALUE is generated if
        - either program or shader is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - shader is not a shader object.
        - shader is already attached to program, or
        - (in ES 2.0 only) another shader object of the same type as shader is already attached to program.

associated gets:
    glGetAttachedShaders with the handle of a valid program object
    glIsProgram
    glIsShader








glBindAttribLocation — associate a generic vertex attribute index with a named attribute variable
    void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);

program:
    Specifies the handle of the program object in which the association is to be made.
index:
    Specifies the index of the generic vertex attribute to be bound.
name:
    Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.

glBindAttribLocation is used to associate a user-defined attribute variable in the program object specified by program with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in name. The generic vertex attribute index to be bound to this variable is specified by index. When program is made part of current state, values provided via the generic vertex attribute index will modify the value of the user-defined attribute variable specified by name.

If name refers to a matrix attribute variable, index refers to the first column of the matrix. Other matrix columns are then automatically bound to locations index+1 for a matrix of type mat2; index+1 and index+2 for a matrix of type mat3; and index+1, index+2, and index+3 for a matrix of type mat4.

This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from 0 to GL_MAX_VERTEX_ATTRIBS -1. The values sent to each generic attribute index are part of current state, (just like standard vertex attributes such as color, normal, and vertex position)[omitted in GL4]. If a different program object is made current by calling glUseProgram, the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to index.

Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling glBindAttribLocation. Attribute bindings do not go into effect until glLinkProgram is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs.

(Applications are not allowed to bind any of the standard OpenGL vertex attributes using this command, as they are bound automatically when needed.)[omitted in GL4] Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.


Notes

glBindAttribLocation can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.

If name was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index.

Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called aliasing, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing. (Because there is no way to bind standard attributes, it is not possible to alias generic attributes with conventional ones (except for generic attribute 0).)[omitted in GL4]

Active attributes that are not explicitly bound will be bound by the linker when glLinkProgram is called. The locations assigned can be queried by calling glGetAttribLocation.

OpenGL copies the name string when glBindAttribLocation is called, so an application may free its copy of the name string immediately after the function returns.

errors:
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - name starts with the reserved prefix "gl_".
        - program is not a program object.

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS
    glGetActiveAttrib with argument program
    glGetAttribLocation with arguments program and name
    glIsProgram











glBindBuffer — bind a named buffer object
    void glBindBuffer(GLenum target, GLuint buffer);

target:
    Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER [purpose: Vertex attributes, according to GL4] or GL_ELEMENT_ARRAY_BUFFER [purpose: Vertex array indices, according to GL4]. Limitation as per GL ES 2.0.
buffer:
    Specifies the name of a buffer object.

glBindBuffer lets you create or use a named buffer object. Calling glBindBuffer with target set to GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER and buffer set to the name of the new buffer object binds the buffer object name to the target. (If no buffer object with name buffer exists, one is created with that name.)[GL4 only] When a buffer object is bound to a target, the previous binding for that target is automatically broken.

Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target ((if supported for that target))[GL 4 only]. Buffer object names and the corresponding buffer object contents are local to the shared (object space)[as per ES 2.0 and GL4]/(display-list space (see glXCreateContext))[as per GL 2.1] of the current GL rendering context(; two rendering contexts share buffer object names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in ES 2.0]

(You may use glGenBuffers to generate a set of new buffer object names.)[GL ES 2.0, GL 2.1]/(glGenBuffers must be used to generate a set of unused buffer object names.)[GL 4]

The state of a buffer object immediately after it is first bound is a[n] (unmapped)[omitted in GL ES 2.0] zero-sized memory buffer with (GL_READ_WRITE access and)[omitted in GL ES 2.0] GL_STATIC_DRAW usage.

While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an GL_INVALID_OPERATION error.

When vertex array pointer state is changed (by a call to glVertexAttribPointer)[ES 2.0]/(for example by a call to glNormalPointer)[GL 2.1], the current buffer object binding (GL_ARRAY_BUFFER_BINDING) is copied into the corresponding client state for (the vertex attrib array being changed, one of the indexed GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDINGs)[ES 2.0]/(vertex array type being changed, for example GL_NORMAL_ARRAY_BUFFER_BINDING.)[GL 2.1]. While a non-zero buffer object is bound to the GL_ARRAY_BUFFER target, the vertex array pointer parameter (that is traditionally interpreted as a pointer to client-side memory)[omited in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, the indices parameter of glDrawElements (that is traditionally interpreted as a pointer to client-side memory)[omitted in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

A buffer object binding created with glBindBuffer remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with glDeleteBuffers.

Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - buffer is not a name previously returned from a call to glGenBuffers. [GL 4 only]

associated gets:
    glGet with argument GL_ARRAY_BUFFER_BINDING
    glGet with argument GL_ELEMENT_ARRAY_BUFFER_BINDING












glBindTexture — bind a named texture to a texturing target
    void glBindTexture(GLenum target, GLuint texture);

target:
    Specifies the target (of the active texture unit)[only GL ES 2.0] to which the texture is bound. Must be either GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP. Limitation as per GL ES 2.0
texture:
    Specifies the name of a texture.

glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP and texture set to the name of the new texture binds the texture name to the target (of the current active texture unit)[GL ES 2.0 only]. When a texture is bound to a target, the previous binding for that target is automatically broken.

Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared (object space)[GL ES 2.0, GL 4]/(display-list space (see glXCreateContext))[GL 2.1] of the current GL rendering context(; two rendering contexts share texture names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in GL ES 2.0].

You (may)[GL 2.1, ES 2.0]/(must)[GL 4] use glGenTextures to generate a set of new texture names.

When a texture is first bound, it assumes the specified target: A texture first bound to GL_TEXTURE_2D becomes a two-dimensional texture and a texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped texture. The state of a two-dimensional texture immediately after it is first bound is equivalent to the state of the default GL_TEXTURE_2D at GL initialization, and similarly for cube-mapped textures.

While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. (If texture mapping is active on the target to which a texture is bound, the bound texture is used.)[GL 2.1 only] In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.

A texture binding created with glBindTexture remains active until a different texture is bound to the same target, or until the bound texture is deleted with glDeleteTextures.

Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use glBindTexture to bind an existing named texture to one of the texture targets than it is to reload the texture image using glTexImage2D. (For additional control over performance, use glPrioritizeTextures. glBindTexture is included in display lists. )[GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - texture is not a name returned from a previous call to glGenTextures.  [GL 4 only]
    GL_INVALID_OPERATION is generated if
        - texture was previously created with a target that doesn't match that of target.

associated gets:
    glGet with argument GL_TEXTURE_BINDING_2D or GL_TEXTURE_BINDING_CUBE_MAP







glBlendColor — set the blend color
    void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); [GL ES 2.0, GL 2.1]
    void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); [GL 4]

red, green, blue, alpha:
    specify the components of GL_BLEND_COLOR

The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The color components are clamped to the range [0, 1] before being stored. See glBlendFunc for a complete description of the blending operations. Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0).

Notes:

glBlendColor is part of the ARB_imaging subset. glBlendColor is present only if ARB_imaging is returned when glGetString is called with GL_EXTENSIONS as its argument. [GL 2.1 only]

The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

assigned gets:
    glGet with an argument of GL_BLEND_COLOR






glBlendEquation — specify the equation used for both the RGB blend equation and the Alpha blend equation
    void glBlendEquation(GLenum mode);

mode:
    specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT. Limitation as per GL ES 2.0

The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation.

These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA




glBlendEquationSeparate — set the RGB blend equation and the alpha blend equation separately
    void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);

modeRGB:
    specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.
modeAlpha:
    specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function specifies one blend equation for the RGB-color components and one blend equation for the alpha component.

The blend equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA






glBlendFunc — specify pixel arithmetic
    void glBlendFunc(GLenum sfactor, GLenum dfactor);

sfactor:
     Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.

dfactor:
    Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.

(In RGBA mode,)[only GL 2.1] Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending.

glBlendFunc defines the operation of blending when it is enabled. sfactor specifies which method is used to scale the source color components. dfactor specifies which method is used to scale the destination color components. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, source and destination color components are referred to as (Rs, Gs, Bs, As) and (Rd, Gd, Bd, Ad). The color specified by glBlendColor is referred to as (Rc, Gc, Bc, Ac). They are understood to have integer values between 0 and (kR, kG, kB, kA), where

kc = 2^mc - 1

and (mR, mG, mB, mA) is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as (sR, sG, sB, sA) and dR dG dB dA. The scale factors described in the table, denoted (fR, fG, fB, fA), represent either source or destination factors. All scale factors have range [0, 1].

Parameter 	                     (fR, fG, fB, fA)
GL_ZERO 	                     (0, 0, 0, 0)
GL_ONE 	                         (1, 1, 1, 1)
GL_SRC_COLOR 	                 (Rs/kR, Gs/kG, Bs/kB, As/kA)
GL_ONE_MINUS_SRC_COLOR 	         (1, 1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB, As/kA)
GL_DST_COLOR 	                 (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
GL_ONE_MINUS_DST_COLOR 	         (1, 1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
GL_SRC_ALPHA 	                 (As/kA, As/kA, As/kA, As/kA)
GL_ONE_MINUS_SRC_ALPHA 	         (1, 1, 1, 1) - (As/kA, As/kA, As/kA, As/kA)
GL_DST_ALPHA 	                 (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
GL_ONE_MINUS_DST_ALPHA 	         (1, 1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
GL_CONSTANT_COLOR 	             (Rc, Gc, Bc, Ac)
GL_ONE_MINUS_CONSTANT_COLOR 	 (1, 1, 1, 1) - (Rc, Gc, Bc, Ac)
GL_CONSTANT_ALPHA 	             (Ac, Ac, Ac, Ac)
GL_ONE_MINUS_CONSTANT_ALPHA 	 (1, 1, 1, 1) - (Ac, Ac, Ac, Ac)
GL_SRC_ALPHA_SATURATE 	         (i, i, i, 1)

In the table,

i = min(As, kA - Ad)/kA

To determine the blended RGBA values of a pixel (when drawing in RGBA mode)[only GL 2.1], the system uses (one of the equations set by glBlendEquation or glBlendEquationSeparate.)[GL ES 2.0]/(the following equations: Rd = min(kR,(Rs*sR)+(Rd*dR)), Gd = min(kG,(Gs*sG)+(Gd*dG)), Bd=min(kB,(Bs*sB)+(Bd*dB)), Ad=min(kA,(As*sA)+(Ad*dA)))[GL 2.1, GL 4]

(Despite the apparent precision of the above equations,)[omitted in GL ES 2.0] Blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. (For example, when sfactor is GL_SRC_ALPHA, dfactor is GL_ONE_MINUS_SRC_ALPHA, and A s is equal to k A , the equations reduce to simple replacement: Rd = Rs, Gd = Gs, Bd = Bs, Ad = As)[omitted in GL ES 2.0]

Examples

Transparency is best implemented using blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) with primitives sorted from farthest to nearest. Note that this transparency calculation does not require the presence of alpha bitplanes in the frame buffer.

(Blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) is also useful for rendering antialiased points and lines in arbitrary order.

Polygon antialiasing is optimized using blend function (GL_SRC_ALPHA_SATURATE, GL_ONE) with polygons sorted from nearest to farthest. (See the glEnable, glDisable reference page and the GL_POLYGON_SMOOTH argument for information on polygon antialiasing.) Destination alpha bitplanes, which must be present for this blend function to operate correctly, store the accumulated coverage.)[omitted in GL ES 2.0]

Notes

Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency.

(Blending affects only RGBA rendering. It is ignored by color index renderers.)[only GL 2.1]

errors:
    GL_INVALID_ENUM is generated if
        - either sfactor or dfactor is not an accepted value.

associated gets:
    glGet with argument GL_BLEND_SRC_RGB or GL_BLEND_SRC_ALPHA
    glGet with argument GL_BLEND_SRC [only GL 2.1]
    glGet with argument GL_BLEND_DST_RGB or GL_BLEND_DST_ALPHA
    glGet with argument GL_BLEND_DST [only GL 2.1]
    glIsEnabled with argument GL_BLEND








glBlendFuncSeparate — specify pixel arithmetic for RGB and alpha components separately
    void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

srcRGB:
    Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.

dstRGB:
    Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.

srcAlpha:
    Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. The initial value is GL_ONE.

dstAlpha:
    Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO.



(In RGBA mode,)[only GL 2.1] Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending.

glBlendFuncSeparate defines the operation of blending when it is enabled. srcRGB specifies which method is used to scale the source RGB-color components. dstRGB specifies which method is used to scale the destination RGB-color components. Likewise, srcAlpha specifies which method is used to scale the source alpha color component, and dstAlpha specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.

In the table and in subsequent equations, source and destination color components are referred to as (Rs, Gs, Bs, As) and (Rd, Gd, Bd, Ad). The color specified by glBlendColor is referred to as (Rc, Gc, Bc, Ac). They are understood to have integer values between 0 and (kR, kG, kB, kA), where

kc = 2^mc - 1

and (mR, mG, mB, mA) is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as (sR, sG, sB, sA) and dR dG dB dA. All scale factors have range [0, 1].

Parameter 	                     RGB Factor 	                                   Alpha Factor
GL_ZERO 	                     (0, 0, 0)                                         0
GL_ONE 	                         (1, 1, 1)                                         1
GL_SRC_COLOR 	                 (Rs/kR, Gs/kG, Bs/kB)                             As/kA
GL_ONE_MINUS_SRC_COLOR 	         (1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB)                 1 - As/kA
GL_DST_COLOR 	                 (Rd/kR, Gd/kG, Bd/kB)                             Ad/kA
GL_ONE_MINUS_DST_COLOR 	         (1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB)                 1 - Ad/kA
GL_SRC_ALPHA 	                 (As/kA, As/kA, As/kA)                             As/kA
GL_ONE_MINUS_SRC_ALPHA 	         (1, 1, 1) - (As/kA, As/kA, As/kA)                 1 - As/kA
GL_DST_ALPHA 	                 (Ad/kA, Ad/kA, Ad/kA)                             Ad/kA
GL_ONE_MINUS_DST_ALPHA 	         (1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA)                 1 - Ad/kA
GL_CONSTANT_COLOR 	             (Rc, Gc, Bc)                                      Ac
GL_ONE_MINUS_CONSTANT_COLOR 	 (1, 1, 1) - (Rc, Gc, Bc)                          1 - Ac
GL_CONSTANT_ALPHA 	             (Ac, Ac, Ac)                                      Ac
GL_ONE_MINUS_CONSTANT_ALPHA 	 (1, 1, 1) - (Ac, Ac, Ac)                          1 - Ac
GL_SRC_ALPHA_SATURATE 	         (i, i, i)                                         1

In the table,

i = min(As, kA - Ad)/kA

To determine the blended RGBA values of a pixel (when drawing in RGBA mode)[only GL 2.1], the system uses (one of the equations set by glBlendEquation or glBlendEquationSeparate.)[GL ES 2.0]/(the following equations: Rd = min(kR,(Rs*sR)+(Rd*dR)), Gd = min(kG,(Gs*sG)+(Gd*dG)), Bd=min(kB,(Bs*sB)+(Bd*dB)), Ad=min(kA,(As*sA)+(Ad*dA)))[GL 2.1, GL 4]

Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. (For example, when sfactor is GL_SRC_ALPHA, dfactor is GL_ONE_MINUS_SRC_ALPHA, and A s is equal to k A , the equations reduce to simple replacement: Rd = Rs, Gd = Gs, Bd = Bs, Ad = As)[omitted in GL ES 2.0]

Notes

Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency.

(Blending affects only RGBA rendering. It is ignored by color index renderers.)[only GL 2.1]

errors:
    GL_INVALID_ENUM is generated if
        - srcRGB, dstRGB, srcAlpha, or dstAlpha is not an accepted value. [according to ref, GL 2.1 and GL 4 doesn't give an error for incorrect srcAlpha and dstAlpha]

associated gets:
    glGet with argument GL_BLEND_SRC_RGB
    glGet with argument GL_BLEND_SRC_ALPHA
    glGet with argument GL_BLEND_DST_RGB
    glGet with argument GL_BLEND_DST_ALPHA
    glIsEnabled with argument GL_BLEND











glBufferData — create and initialize a buffer object's data store
    void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage);

target:
    Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER. Limitation as per GL ES 2.0

size:
    Specifies the size in bytes of the buffer object's new data store.

data:
    Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.

usage:
    Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STATIC_DRAW, or GL_DYNAMIC_DRAW. Limitation as per GL ES 2.0

glBufferData creates a new data store for the buffer object currently bound to target. (While creating the new storage,)[GL ES 2.0] Any pre-existing data store is deleted. The new data store is created with the specified size in bytes and usage. If data is not NULL, the data store is initialized with data from this pointer. (In its initial state, the new data store is not mapped, it has a NULL mapped pointer, and its mapped access is GL_READ_WRITE.)[omitted in GL ES 2.0]

usage is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. usage can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these:

STREAM
    The data store contents will be modified once and used at most a few times.

STATIC
    The data store contents will be modified once and used many times.

DYNAMIC
    The data store contents will be modified repeatedly and used many times.

The nature of access must be: [Limitation as per GL ES 2.0]

DRAW
    The data store contents are modified by the application, and used as the source for GL drawing and image specification commands.


Notes

If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.

Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N (bytes)[omitted in GL ES 2.0] be a multiple of N.

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
        - usage is not GL_STREAM_DRAW, GL_STATIC_DRAW, or GL_DYNAMIC_DRAW.
    GL_INVALID_VALUE is generated if
        - size is negative.
    GL_INVALID_OPERATION is generated if
        - the reserved buffer object name 0 is bound to target.
    GL_OUT_OF_MEMORY is generated if
        - the GL is unable to create a data store with the specified size.

associated gets:
    glGetBufferSubData [omitted in GL ES 2.0]
    glGetBufferParameteriv with argument GL_BUFFER_SIZE or GL_BUFFER_USAGE











glBufferSubData — update a subset of a buffer object's data store
    void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);

target
    Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.

offset
    Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.

size
    Specifies the size in bytes of the data store region being replaced.

data
    Specifies a pointer to the new data that will be copied into the data store.

glBufferSubData redefines some or all of the data store for the buffer object currently bound to target. Data starting at byte offset offset and extending for size bytes is copied to the data store from the memory pointed to by data. An error is thrown if offset and size together define a range beyond the bounds of the buffer object's data store.

Notes

When replacing the entire data store, consider using glBufferSubData rather than completely recreating the data store with glBufferData. This avoids the cost of reallocating the data store.

Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by glBufferSubData, especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated.

Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N (bytes)[omitted in GL ES 2.0] be a multiple of N.

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
    GL_INVALID_VALUE is generated if
        - offset or size is negative, or if (together they define a region of memory that extends beyond the buffer object's allocated data store)[GL ES 2.0, GL 2.1]/(offset+size is greater than the value of GL_BUFFER_SIZE for the specified buffer object)[GL 4].
    GL_INVALID_OPERATION is generated if
        - the reserved buffer object name 0 is bound to target.
        - if the buffer object being updated is mapped.  [only GL 2.1]
        - GL_INVALID_OPERATION is generated if the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set. [only GL 4]











glClear — clear buffers to preset values
    void glClear(GLbitfield mask);

mask:
    Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.

glClear sets the bitplane area of the window to values previously selected by glClearColor, glClearDepth[f], and glClearStencil.

The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of glClear. The scissor box bounds the cleared region. Blend function, stenciling, (fragment shading)[only in GL ES 2.0], and depth-buffering are ignored by glClear.

glClear takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.

The values are as follows:

GL_COLOR_BUFFER_BIT
    Indicates the buffers currently enabled for color writing.

GL_DEPTH_BUFFER_BIT
    Indicates the depth buffer.

GL_STENCIL_BUFFER_BIT
    Indicates the stencil buffer.

The value to which each buffer is cleared depends on the setting of the clear value for that buffer.

Notes

If a buffer is not present, then a glClear directed at that buffer has no effect.

errors:
    GL_INVALID_VALUE is generated if
        - any bit other than the three defined bits is set in mask.

associated gets:
    glGet with argument GL_DEPTH_CLEAR_VALUE
    glGet with argument GL_COLOR_CLEAR_VALUE
    glGet with argument GL_STENCIL_CLEAR_VALUE











glClearColor — specify clear values for the color buffers
    void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); [GL ES 2.0, GL 2.1]
    void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); [GL 4]

red, green, blue, alpha:
    Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.

glClearColor specifies the red, green, blue, and alpha values used by glClear to clear the color buffers. Values specified by glClearColor are clamped to the range [0, 1].

Notes

The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

associated gets:
    glGet with argument GL_COLOR_CLEAR_VALUE








glClearDepth[f] — specify the clear value for the depth buffer
    void glClearDepthf(GLclampf depth); [in GL ES 2.0]
    void glClearDepthf(GLfloat depth); [in GL 4.1+]
    void glClearDepth(GLclampd depth); [in GL 2.1]
    void glClearDepth(GLdouble depth); [in GL 4]

depth:
    Specifies the depth value used when the depth buffer is cleared. The initial value is 1.

glClearDepth[f] specifies the depth value used by glClear to clear the depth buffer. Values specified by glClearDepth[f] are clamped to the range [0, 1].

Notes

The type of the depth parameter was changed from GLclampf to GLfloat for glClearDepthf and from GLclampd to GLdouble for glClearDepth. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

associated gets:
    glGet with argument GL_DEPTH_CLEAR_VALUE









glClearStencil — specify the clear value for the stencil buffer
    void glClearStencil(GLint s);

s:
    Specifies the index used when the stencil buffer is cleared. The initial value is 0.

glClearStencil specifies the index used by glClear to clear the stencil buffer. s is masked with 2^m - 1 ,where m is the number of bits in the stencil buffer.

associated gets:
    glGet with argument GL_STENCIL_CLEAR_VALUE
    glGet with argument GL_STENCIL_BITS









glColorMask — enable and disable writing of frame buffer color components
    void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

red, green, blue, alpha:
    Specify whether red, green, blue, and alpha can or cannot be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components can be written.

glColorMask specifies whether the individual color components in the frame buffer can or cannot be written. If red is GL_FALSE, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.

Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.

associated gets:
    glGet with argument GL_COLOR_WRITEMASK
    glGet with argument GL_RGBA_MODE [GL 2.1 only]










glCompileShader — compile a shader object
    void glCompileShader(GLuint shader);

shader:
    Specifies the shader object to be compiled.

(For implementations that support a shader compiler,)[GL ES 2.0 only] glCompileShader compiles the source code strings that have been stored in the shader object specified by shader.

The compilation status will be stored as part of the shader object's state. This value will be set to GL_TRUE if the shader was compiled without errors and is ready for use, and GL_FALSE otherwise. It can be queried by calling (glGetShaderiv)[GL ES 2.0]/(glGetShader)[GL 2.1, GL 4] with arguments shader and GL_COMPILE_STATUS.

Compilation of a shader can fail for a number of reasons as specified by the OpenGL (ES)[GL ES 2.0 only] Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling glGetShaderInfoLog.


Notes

Shader compiler support is optional, and thus must be queried before use by calling glGet with argument GL_SHADER_COMPILER. glShaderSource, glCompileShader, glGetShaderPrecisionFormat, and glReleaseShaderCompiler will each generate GL_INVALID_OPERATION on implementations that do not support a shader compiler. Such implementations instead offer the glShaderBinary alternative for supplying a pre-compiled shader binary. [GL ES 2.0 only]


errors:
    GL_INVALID_OPERATION is generated if
        - shader is not a shader object.
        - a shader compiler is not supported. [GL ES 2.0 only]
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.

associated gets:
    glGet with argument GL_SHADER_COMPILER [GL ES 2.0 only]
    glGetShaderInfoLog with argument shader
    (glGetShaderiv)[GL ES 2.0]/(glGetShader)[GL 2.1, GL 4] with arguments shader and GL_COMPILE_STATUS
    glIsShader














glCompressedTexImage2D — specify a two-dimensional texture image in a compressed format
    void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat,
        GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);

target
    Specifies the target texture (of the active texture unit)[GL ES 2.0 only]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. Limitation as per GL ES 2.0

level
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

internalformat
    Specifies the format of the compressed image data stored at address data.

width
    Specifies the width of the texture image (including the border if any)[only GL 2.1]. (If the GL version does not support non-power-of-two sizes, this value must be 2 n + 2 ⁡ border for some integer n.)[only GL 2.1] All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.

height
    Specifies the height of the texture image (including the border if any)[only GL 2.1]. (If the GL version does not support non-power-of-two sizes, this value must be Must be 2 n + 2 ⁡ border for some integer n.)[only GL 2.1] All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.

border
    Specifies the width of the border. Must be 0. Limitation as per GL ES 2.0 and GL 4

imageSize
    Specifies the number of unsigned bytes of image data starting at the address specified by data.

data
    Specifies a pointer to the compressed image data in memory.

Texturing (maps a portion of a specified texture image onto each graphical primitive for which texturing is (active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0]/(enabled. To enable and disable two-dimensional texturing, call glEnable and glDisable with argument GL_TEXTURE_2D. To enable and disable texturing using cube-mapped textures, call glEnable and glDisable with argument GL_TEXTURE_CUBE_MAP.)[GL 2.1])[GL ES 2.0, GL 2.1] / (allows elements of an image array to be read by shaders.)[GL 4]

(glCompressedTexImage2D defines a two-dimensional texture image or cube-map texture image using compressed image data from client memory. The texture image is decoded according to the extension specification defining the specified internalformat. OpenGL ES defines no specific compressed texture formats, but does provide a mechanism to obtain symbolic constants for such formats provided by extensions. The number of compressed texture formats supported can be obtained by querying the value of GL_NUM_COMPRESSED_TEXTURE_FORMATS. The list of specific compressed texture formats supported can be obtained by querying the value of GL_COMPRESSED_TEXTURE_FORMATS.
)[GL ES 2.0]

(glCompressedTexImage2D loads a previously defined, and retrieved, compressed two-dimensional texture image if target is GL_TEXTURE_2D(, or one of the cube map faces such as GL_TEXTURE_CUBE_MAP_POSITIVE_X.)[GL 4 only] (see glTexImage2D).

internalformat must be (a known compressed image format (such as GL_RGTC) or)[only GL 4] an extension-specified compressed-texture format. When a texture is loaded with glTexImage2D using a generic compressed texture format (e.g., GL_COMPRESSED_RGB), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using glCompressedTexImage2D, query the compressed texture image's size and format using glGetTexLevelParameter.

If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image is specified, data is treated as a byte offset into the buffer object's data store.
)[GL 2.1, GL 4]

(If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for glTexImage2D. In the following description, denote by bs, bw, bh, and bd, the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE, GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT, and GL_UNPACK_COMPRESSED_BLOCK_DEPTH, respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth in pixels.

By default the pixel storage modes GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH, bs and bw must both be non-zero. To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT, bh must be non-zero. To also enable GL_UNPACK_SKIP_IMAGES, bd must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.

When selecting a sub-rectangle from a compressed image:
 - The value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw;
 - the value of GL_UNPACK_SKIP_ROWS must be a multiple of bw.
imageSize must be equal to:
    bs * ceil(width/bw)*ceil(height/bh))[GL 4 only]



Notes

(A GL implementation may choose to store the texture array at any internal resolution it chooses.

glCompressedTexImage2D specifies a two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture.)[GL ES 2.0]



errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. [GL ES 2.0 only]
        - internalformat is not a supported format returned in GL_COMPRESSED_TEXTURE_FORMATS. [GL ES 2.0 only]
        - internalformat is one of the generic compressed internal formats: GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, or GL_COMPRESSED_RGBA. [GL 2.1 only]
        - internalformat is not one of the specific compressed internal formats: GL_COMPRESSED_RED_RGTC1, GL_COMPRESSED_SIGNED_RED_RGTC1, GL_COMPRESSED_RG_RGTC2, GL_COMPRESSED_SIGNED_RG_RGTC2. GL_COMPRESSED_RGBA_BPTC_UNORM, GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_RG11_EAC, or GL_COMPRESSED_SIGNED_RG11_EAC. [GL 4 only]
    GL_INVALID_VALUE is generated if
        - level is less than 0.  [GL ES 2.0 only]
        - width or height is less than 0 or greater than GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D. [GL ES 2.0 only]
        - border is not 0. [GL ES 2.0, GL 4]
        - imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data.
    GL_INVALID_VALUE may be generated if
        - level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.  [GL ES 2.0 only]
    GL_INVALID_OPERATION is generated if
        - parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. [GL 2.1, GL 4]
    Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format.


associated gets:
    glGet with arguments GL_NUM_COMPRESSED_TEXTURE_FORMATS and GL_COMPRESSED_TEXTURE_FORMATS [GL ES 2.0]
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0]
    (glGetCompressedTexImage
    glGet with argument GL_TEXTURE_COMPRESSED
    glGet with argument GL_PIXEL_UNPACK_BUFFER_BINDING
    glGetTexLevelParameter with arguments GL_TEXTURE_INTERNAL_FORMAT and GL_TEXTURE_COMPRESSED_IMAGE_SIZE) [GL 2.1 and GL 4]
    glIsEnabled with argument GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP [GL 2.1 only]











glCompressedTexSubImage2D — specify a two-dimensional texture subimage in a compressed format
    void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
        GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);

target
    Specifies the target (texture (of the active texture unit)[GL ES 2.0 only])[GL ES 2.0, GL 2.1]/(to which the texture is bound)[GL 4]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. Limitation as per GL ES 2.0 and GL 2.1

level
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

xoffset
    Specifies a texel offset in the x direction within the texture array.

yoffset
    Specifies a texel offset in the y direction within the texture array.

width
    Specifies the width of the texture subimage.

height
    Specifies the height of the texture subimage.

format
    Specifies the format of the compressed image data stored at address data.

imageSize
    Specifies the number of unsigned bytes of image data starting at the address specified by data.

data
    Specifies a pointer to the compressed image data in memory.

Texturing (maps a portion of a specified texture image onto each graphical primitive for which texturing is (active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0]/(enabled. To enable and disable two-dimensional texturing, call glEnable and glDisable with argument GL_TEXTURE_2D. To enable and disable texturing using cube-mapped textures, call glEnable and glDisable with argument GL_TEXTURE_CUBE_MAP.)[GL 2.1])[GL ES 2.0, GL 2.1] / (allows elements of an image array to be read by shaders.)[GL 4]

glCompressedTexSubImage2D redefines a contiguous subregion of an existing two-dimensional texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset and xoffset + width - 1 , and the y indices yoffset and yoffset + height - 1 , inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.

(format)[GL ES 2.0, GL 2.1]/(internalformat)[GL 4] must be (the same extension-specified compressed-texture format previously specified by glCompressedTexImage2D.)[GL ES 2.0]/((a known compressed image format (such as GL_RGTC) or)[GL 4 only] an extension-specified compressed-texture format. The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage2D) and should be queried at the time the texture was compressed with glGetTexLevelParameter.

If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image is specified, data is treated as a byte offset into the buffer object's data store.)[GL 2.1, GL 4]

Notes

(glCompressedTexSubImage2D specifies a two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture.)[GL ES 2.0]


errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. [GL ES 2.0 only]
        - format is not a supported format returned in GL_COMPRESSED_TEXTURE_FORMATS. [GL ES 2.0 only]
        - format is one of these generic compressed internal formats: GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SLUMINANCE, GL_COMPRESSED_SLUMINANCE_ALPHA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGBA, or GL_COMPRESSED_SRGB_ALPHA. [GL 2.1 only]
        - internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. [GL 4 only]
        - target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE. [GL 4 only]
    GL_INVALID_VALUE is generated if
        - level is less than 0.  [GL ES 2.0 only]
        - xoffset < 0 , xoffset + width > w , yoffset < 0 , or yoffset + height > h , where w is the width and h is the height of the texture image being modified. [GL ES 2.0 only]
        - width or height is less than 0 [GL ES 2.0 only]
        - imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data.
    GL_INVALID_VALUE may be generated if
        - level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.  [GL ES 2.0 only]
    GL_INVALID_OPERATION is generated if
        - the texture array has not been defined by a previous glCompressedTexImage2D operation whose internalformat matches the format of glCompressedTexSubImage2D.[GL ES 2.0 only]
        - parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. [GL 2.1, GL 4]
    Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format.


associated gets:
    glGet with arguments GL_NUM_COMPRESSED_TEXTURE_FORMATS and GL_COMPRESSED_TEXTURE_FORMATS [GL ES 2.0]
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0]
    (glGetCompressedTexImage
    glGet with argument GL_TEXTURE_COMPRESSED
    glGet with argument GL_PIXEL_UNPACK_BUFFER_BINDING
    glGetTexLevelParameter with arguments GL_TEXTURE_INTERNAL_FORMAT and GL_TEXTURE_COMPRESSED_IMAGE_SIZE) [GL 2.1 and GL 4]
    glIsEnabled with argument GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP [GL 2.1 only]
















glCopyTexImage2D — copy pixels into a 2D texture image
    void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y,
        GLsizei width, GLsizei height, GLint border);

target
    Specifies the target texture (of the active texture unit)[GL ES 2.0 only]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.

level
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

internalformat
    Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_RGB, or GL_RGBA. Limitation as per GL ES 2.0 and GL 4

x, y
    Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.

width
    Specifies the width of the texture image. (All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.)[GL ES 2.0]/(Must be 0 or 2 n + 2 ⁡ border for some integer n.)[GL 2.1]

height
    Specifies the height of the texture image. (All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.)[GL ES 2.0]/(Must be 0 or 2 m + 2 ⁡ border for some integer m.)[GL 2.1]

border
    Specifies the width of the border. Must be 0. Limitation as per GL ES 2.0 and GL 4

(Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0 only]

glCopyTexImage2D defines a two-dimensional texture image or cube-map texture image with pixels from the current (framebuffer (rather than from client memory, as is the case for glTexImage2D).)[GL ES 2.0]/(GL_READ_BUFFER)[GL 2.1, GL 4]

The screen-aligned pixel rectangle with lower left corner at (x, y) and with a width of width + 2*border and a height of height + 2*border defines the texture array at the mipmap level specified by level. internalformat specifies the internal format of the texture array.


The pixels in the rectangle are processed exactly as if (glReadPixels)[GL ES 2.0, GL 4]/(glCopyPixels)[GL 2.1] had been called (with format set to GL_RGBA)[GL ES 2.0 only], but the process stops just (after conversion of RGBA values. Subsequent processing is identical to that described for glTexImage2D, beginning with the clamping of the R, G, B, and A values to the range [0, 1] and then conversion to the texture's internal format for storage in the texel array.)[GL ES 2.0]/(before final conversion. At this point all pixel component values are clamped to the range [0, 1] and then converted to the texture's internal format for storage in the texel array.)[GL 2.1, GL 4]

(The components required for internalformat must be a subset of those present in the framebuffer's format. For example, a GL_RGBA framebuffer can be used to supply components for any internalformat. However, a GL_RGB framebuffer can only be used to supply components for GL_RGB or GL_LUMINANCE base internal format textures, not GL_ALPHA, GL_LUMINANCE_ALPHA, or GL_RGBA textures.)[GL ES 2.0 only]

Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates.

If any of the pixels within the specified rectangle (are outside the framebuffer)[GL ES 2.0]/(of the current GL_READ_BUFFER are outside the window)[GL 2.1, GL 4] associated with the current rendering context, then the values obtained for those pixels are undefined.

(When internalformat is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the glPixelMap function can be used to accomplish the conversion.)[omitted in GL ES 2.0]

Notes

(A GL implementation may choose to store the texture array at any internal resolution it chooses.)[GL ES 2.0 only]

(Texturing has no effect in color index mode.)[GL 2.1 only]

(1, 2, 3, and 4 are not accepted values for internalformat. )[GL 2.1, GL 4]

An image with height or width of 0 indicates a NULL texture.

(glCopyTexImage2D specifies a two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture. )

(When the ARB_imaging extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline. See glTexImage1D for specific details. )[GL 2.1 only]


errors:
GL_INVALID_ENUM is generated if
    - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
    - internalformat is not an accepted format. [GL ES 2.0 only]
GL_INVALID_VALUE is generated if
    - target is one of the six cube map 2D image targets and the width and height parameters are not equal. [GL ES 2.0 only]
    - level is less than 0.
    - width (or height)[GL ES 2.0 only] is less than 0 or greater than (GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.)[GL ES 2.0]/(2 + GL_MAX_TEXTURE_SIZE.)[GL 2.1]/(GL_MAX_TEXTURE_SIZE)[GL 4]
    - border is not 0. [GL ES 2.0, GL 4] / border is not 0 or 1. [GL 2.1]
    - non-power-of-two textures are not supported and the width or depth cannot be represented as 2 k + 2 ⁡ border for some integer k. [GL 2.1 only]
    - internalformat is not an accepted format. [GL 2.1 only]
GL_INVALID_VALUE may be generated if
    - level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE (when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.)[GL ES 2.0]
GL_INVALID_OPERATION is generated if
    - the currently bound framebuffer's format does not contain a superset of the components required by the base format of internalformat. [GL ES 2.0 only]
    - internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth buffer. [GL 2.1, GL 4]
GL_INVALID_FRAMEBUFFER_OPERATION is generated if
    - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). [GL ES 2.0 only]

associated gets:
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0 only]
    glGetTexImage [GL 2.1, GL 4]
    glIsEnabled with argument GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP [GL 2.1 only]

















glCopyTexSubImage2D — copy a two-dimensional texture subimage
    void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y,
        GLsizei width, GLsizei height);

target:
    Specifies the target (texture (of the active texture unit)[GL ES 2.0 only].)[GL ES 2.0, GL 2.1]/(to which the texture object is bound)[GL 4] Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.

level:
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

xoffset:
    Specifies a texel offset in the x direction within the texture array.

yoffset:
    Specifies a texel offset in the y direction within the texture array.

x, y:
    Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.

width:
    Specifies the width of the texture subimage.

height:
    Specifies the height of the texture subimage.

(Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0 only]

glCopyTexSubImage2D replaces a rectangular portion of a two-dimensional texture image or cube-map texture image with pixels from the current (framebuffer)[GL ES 2.0]/(GL_READ_BUFFER)[GL 2.1, GL 4] (rather than from (client)[GL ES 2.0]/(main)[GL 2.1, GL 4] memory, as is the case for glTexSubImage2D).

The screen-aligned pixel rectangle with lower left corner at (x, y) and with width width and height height replaces the portion of the texture array with x indices xoffset through xoffset + width - 1 , inclusive, and y indices yoffset through yoffset + height - 1 , inclusive, at the mipmap level specified by level.

The pixels in the rectangle are processed exactly as if (glReadPixels)[GL ES 2.0, GL 4]/(glCopyPixels)[GL 2.1] had been called (with format set to GL_RGBA)[only GL ES 2.0], but the process stops just (after conversion of RGBA values. Subsequent processing is identical to that described for glTexSubImage2D, beginning with the clamping of the R, G, B, and A values to the range [0,1] and then conversion to the texture's internal format for storage in the texel array.)[GL ES 2.0]/(before final conversion. At this point, all pixel component values are clamped to the range [0,1] and then converted to the texture's internal format for storage in the texel array.)[GL 2.1, GL 4]

The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.

(When target is GL_TEXTURE_1D_ARRAY then the y coordinate and height are treated as the start slice and number of slices to modify.) [GL 4 only]

If any of the pixels within the specified rectangle (are outside the framebuffer)[GL ES 2.0]/(of the current GL_READ_BUFFER are outside the read window)[GL 2.1, GL 4] associated with the current rendering context, then the values obtained for those pixels are undefined.

No change is made to the internalformat, width, or height (or border)[only GL 2.1] parameters of the specified texture array or to texel values outside the specified subregion.


Notes

glCopyTexSubImage2D specifies the two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture. [only GL ES 2.0]

(Texturing has no effect in color index mode.

glPixelStore and glPixelTransfer modes affect texture images in exactly the way they affect glDrawPixels.

When the ARB_imaging extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline. See glTexImage1D for specific details. )[GL 2.1]

(glPixelStore modes affect texture images. )[GL 4]

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
    GL_INVALID_VALUE is generated if
        - level is less than 0.
        - xoffset < 0 , xoffset + width > w , yoffset < 0 , or yoffset + height > h , where w is the (width)[GL ES 2.0]/(GL_TEXTURE_WIDTH)[GL 4] and h is the (height)[GL ES 2.0]/(GL_TEXTURE_HEIGHT)[GL 4] of the texture image being modified. [GL ES 2.0, GL 4]
        - width or height is less than 0.  [GL ES 2.0 only]
        - xoffset < - b , xoffset + width > w - b , yoffset < - b , or yoffset + height > h - b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the GL_TEXTURE_BORDER of the texture image being modified. Note that w and h include twice the border width. [GL 2.1 only]
        - the effective target is GL_TEXTURE_RECTANGLE and level is not zero. [GL 4 only]
    GL_INVALID_VALUE may be generated if
        - level > log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
    GL_INVALID_OPERATION is generated if
        - the texture array has not been defined by a previous glTexImage2D(, glTexStorage2D)[GL 4 only] or glCopyTexImage2D operation.
        - the currently bound framebuffer's format does not contain a superset of the components required by the texture's base internal format. [GL ES 2.0 only]
        (- the read buffer is GL_NONE, or
        - the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
            the read buffer selects an attachment that has no image attached, or
            the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.)[GL 4 only]
    GL_INVALID_FRAMEBUFFER_OPERATION is generated if
        - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE).  [GL ES 2.0 only]
        - the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete. [GL 4]

associated gets:
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0 only]
    glGetTexImage [GL 2.1, GL 4]
    glIsEnabled with argument GL_TEXTURE_2D [GL 2.1]










glCreateProgram — create a program object
    GLuint glCreateProgram(void);

glCreateProgram creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached.

One or more executables are created in a program object by successfully attaching shader objects to it with glAttachShader, successfully compiling the shader objects with glCompileShader, and successfully linking the program object with glLinkProgram. These executables are made part of current state when glUseProgram is called. Program objects can be deleted by calling glDeleteProgram. The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.

Notes

Like (display lists and)[GL 2.1 only]/(buffer and)[GL 4 only] texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.

Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.

errors:
    This function returns 0 if an error occurs creating the program object.

associated gets:
    glGet with the argument GL_CURRENT_PROGRAM
    glGetActiveAttrib with a valid program object and the index of an active attribute variable
    glGetActiveUniform with a valid program object and the index of an active uniform variable
    glGetAttachedShaders with a valid program object
    glGetAttribLocation with a valid program object and the name of an attribute variable
    glGetProgram(iv)[GL ES 2.0] with a valid program object and the parameter to be queried
    glGetProgramInfoLog with a valid program object
    glGetUniform with a valid program object and the location of a uniform variable
    glGetUniformLocation with a valid program object and the name of a uniform variable
    glIsProgram




glCreateShader — create a shader object
    GLuint glCreateShader(GLenum shaderType);

shaderType
    Specifies the type of shader to be created. Must be either GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. Limitation as per GL ES 2.0 and GL 2.1

glCreateShader creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. shaderType indicates the type of shader to be created. Two types of shaders are supported. A shader of type GL_VERTEX_SHADER is a shader that is intended to run on the programmable vertex processor (and replace the fixed functionality vertex processing in OpenGL)[GL 2.1 only]. A shader of type GL_FRAGMENT_SHADER is a shader that is intended to run on the programmable fragment processor (and replace the fixed functionality fragment processing in OpenGL)[GL 2.1 only].

When created, a shader object's GL_SHADER_TYPE parameter is set to either GL_VERTEX_SHADER or GL_FRAGMENT_SHADER, depending on the value of shaderType.

Notes

Like (display lists and)[GL 2.1 only]/(buffer and)[GL 4 only] texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.

Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.

errors:
    This function returns 0 if an error occurs creating the shader object.
    GL_INVALID_ENUM is generated if
        - shaderType is not an accepted value.

associated gets:
    glGetShader(iv)[GL ES 2.0] with a valid shader object and the parameter to be queried
    glGetShaderInfoLog with a valid shader object
    glGetShaderSource with a valid shader object
    glIsShader








glCullFace — specify whether front- or back-facing (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] can be culled
    void glCullFace(GLenum mode);

mode
    Specifies whether front- or back-facing (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.

glCullFace specifies whether front- or back-facing (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are culled (as specified by mode) when (polygon)[GL ES 2.0]/(facet)[GL 2.1, GL 4] culling is enabled. (Polygon)[GL ES 2.0]/(Facet)[GL 2.1, GL 4] culling is initially disabled. To enable and disable (polygon)[GL ES 2.0]/(facet)[GL 2.1, GL 4] culling, call the glEnable and glDisable commands with the argument GL_CULL_FACE. (Facets include triangles, quadrilaterals, polygons, and rectangles.)[GL 2.1, GL 4]

glFrontFace specifies which of the clockwise and counterclockwise (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are front-facing and back-facing. See glFrontFace.

Notes

If mode is GL_FRONT_AND_BACK, no (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are drawn, but other primitives such as points and lines are drawn.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.

associated gets:
    glIsEnabled with argument GL_CULL_FACE
    glGet with argument GL_CULL_FACE_MODE











glDeleteBuffers — delete named buffer objects
    void glDeleteBuffers(GLsizei n, const GLuint * buffers);

n
    Specifies the number of buffer objects to be deleted.

buffers
    Specifies an array of buffer objects to be deleted.

glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by glGenBuffers). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object, (which reverts to client memory usage)[omitted in GL 4]).

glDeleteBuffers silently ignores 0's and names that do not correspond to existing buffer objects.

errors:
    GL_INVALID_VALUE is generated if
        - n is negative.

associated gets:
    glIsBuffer






glDeleteProgram — delete a program object
    void glDeleteProgram(GLuint program);

program
    Specifies the program object to be deleted.

glDeleteProgram frees the memory and invalidates the name associated with the program object specified by program. This command effectively undoes the effects of a call to glCreateProgram.

If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to glDeleteShader. A value of 0 for program will be silently ignored.

To determine whether a program object has been flagged for deletion, call glGetProgram(iv)[GL ES 2.0 only] with arguments program and GL_DELETE_STATUS.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.

associated gets:
    glGet with argument GL_CURRENT_PROGRAM
    glGetProgram(iv)[GL ES 2.0 only] with arguments program and GL_DELETE_STATUS
    glIsProgram












glDeleteShader — delete a shader object
    void glDeleteShader(GLuint shader);

shader
    Specifies the shader object to be deleted.

glDeleteShader frees the memory and invalidates the name associated with the shader object specified by shader. This command effectively undoes the effects of a call to glCreateShader.

If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for shader will be silently ignored.

To determine whether an object has been flagged for deletion, call glGetShader(iv)[GL ES 2.0 only] with arguments shader and GL_DELETE_STATUS.

errors:
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.

associated gets:
    glGetAttachedShaders with the program object to be queried
    glGetShader(iv)[GL ES 2.0 only] with arguments shader and GL_DELETE_STATUS
    glIsShader















glDeleteTextures — delete named textures
    void glDeleteTextures(GLsizei n, const GLuint * textures);

n
    Specifies the number of textures to be deleted.

textures
    Specifies an array of textures to be deleted.

glDeleteTextures deletes n textures named by the elements of the array textures. After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by glGenTextures). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture).

glDeleteTextures silently ignores 0's and names that do not correspond to existing textures.

errors:
    GL_INVALID_VALUE is generated if
        - n is negative.

associated gets:
    glIsTexture









glDepthFunc — specify the value used for depth buffer comparisons
    void glDepthFunc(GLenum func);

func
    Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.

glDepthFunc specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See glEnable and glDisable of GL_DEPTH_TEST.)

func specifies the conditions under which the pixel will be drawn. The comparison functions are as follows:

GL_NEVER
    Never passes.

GL_LESS
    Passes if the incoming depth value is less than the stored depth value.

GL_EQUAL
    Passes if the incoming depth value is equal to the stored depth value.

GL_LEQUAL
    Passes if the incoming depth value is less than or equal to the stored depth value.

GL_GREATER
    Passes if the incoming depth value is greater than the stored depth value.

GL_NOTEQUAL
    Passes if the incoming depth value is not equal to the stored depth value.

GL_GEQUAL
    Passes if the incoming depth value is greater than or equal to the stored depth value.

GL_ALWAYS
    Always passes.

The initial value of func is GL_LESS. Initially, depth testing is disabled. If depth testing is disabled or (if)[omitted in GL ES 2.0] no depth buffer exists, it is as if the depth test always passes.

Notes

Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. (In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS.)[GL 4 only]

errors:
    GL_INVALID_ENUM is generated if
        - func is not an accepted value.

associated gets:
    glGet with argument GL_DEPTH_FUNC
    glIsEnabled with argument GL_DEPTH_TEST














glDepthMask — enable or disable writing into the depth buffer
    void glDepthMask(GLboolean flag);

flag
    Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.

glDepthMask specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.

Notes

Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS (see glDepthFunc). [GL 4 only]

associated gets:
    glGet with argument GL_DEPTH_WRITEMASK










glDepthRange[f] — specify mapping of depth values from normalized device coordinates to window coordinates
    void glDepthRangef(GLclampf nearVal, GLclampf farVal); [GL ES 2.0]
    void glDepthRangef(GLfloat nearVal, GLfloat farVal); [GL 4]
    void glDepthRange(GLclampd nearVal, GLclampd farVal); [GL 2.1]
    void glDepthRange(GLdouble nearVal, GLdouble farVal); [GL 4]

nearVal
    Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.

farVal
    Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.

After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. glDepthRange[f] specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by glDepthRange[f] are both clamped to this range before they are accepted.

The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.

Notes

It is not necessary that nearVal be less than farVal. Reverse mappings such as nearVal = 1 , and farVal = 0 are acceptable.

The type of the nearVal and farVal parameters was changed from GLclampf to GLfloat for glDepthRangef and from GLclampd to GLdouble for glDepthRange. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

associated gets:
    glGet with argument GL_DEPTH_RANGE
















glDetachShader — detach a shader object from a program object (to which it is attached)[GL 2.1, GL 4]
    void glDetachShader(GLuint program, GLuint shader);

program
    Specifies the program object from which to detach the shader object.

shader
    Specifies the shader object to be detached.

glDetachShader detaches the shader object specified by shader from the program object specified by program. This command can be used to undo the effect of the command glAttachShader.

If shader has already been flagged for deletion by a call to glDeleteShader and it is not attached to any other program object, it will be deleted after it has been detached.

errors:
    GL_INVALID_VALUE is generated if
        - either program or shader is a value that was not generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - shader is not a shader object.
        - shader is not attached to program.

associated gets:
    glGetAttachedShaders with the handle of a valid program object
    glGetShader(iv)[GL ES 2.0 only] with arguments shader and GL_DELETE_STATUS
    glIsProgram
    glIsShader














glEnable — enable or disable server-side GL capabilities
    void glEnable(GLenum cap);
    void glDisable(GLenum cap);

cap:
    Specifies a symbolic constant indicating a GL capability.

glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to determine the current setting of any capability. The initial value for each capability with the exception of GL_DITHER is GL_FALSE. The initial value for GL_DITHER is GL_TRUE.

Both glEnable and glDisable take a single argument, cap, which can assume one of the following values: (Limitation as per GL ES 2.0)

GL_BLEND
    If enabled, blend the computed fragment color values with the values in the color buffers. See glBlendFunc.

GL_CULL_FACE
    If enabled, cull polygons based on their winding in window coordinates. See glCullFace.

GL_DEPTH_TEST
    If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See glDepthFunc and glDepthRangef.

GL_DITHER
    If enabled, dither color components or indices before they are written to the color buffer.

GL_POLYGON_OFFSET_FILL
    If enabled, (and if the polygon is rendered in GL_FILL mode ,)[GL 2.1, GL 4] an offset is added to depth values of a polygon's fragments (produced by rasterization)[GL ES 2.0]/(before the depth comparison is performed)[GL 2.1, GL 4]. See glPolygonOffset.

GL_SAMPLE_ALPHA_TO_COVERAGE
    If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.

GL_SAMPLE_COVERAGE
    If enabled, the fragment's coverage is ANDed with the temporary coverage value. If GL_SAMPLE_COVERAGE_INVERT is set to GL_TRUE, invert the coverage value. See glSampleCoverage.

GL_SCISSOR_TEST
    If enabled, discard fragments that are outside the scissor rectangle. See glScissor.

GL_STENCIL_TEST
    If enabled, do stencil testing and update the stencil buffer. See glStencilFunc and glStencilOp.

errors:
    GL_INVALID_ENUM is generated if
        - cap is not one of the values listed previously.

associated gets:
    glIsEnabled
    glGet











glEnableVertexAttribArray — enable or disable a generic vertex attribute array
    void glEnableVertexAttribArray(GLuint index);
    void glDisableVertexAttribArray(GLuint index);

index:
    Specifies the index of the generic vertex attribute to be enabled or disabled.

glEnableVertexAttribArray enables the generic vertex attribute array specified by index. glDisableVertexAttribArray disables the generic vertex attribute array specified by index. (glEnableVertexAttribArray uses currently bound vertex array object for the operation. glDisableVertexAttribArray disables the generic vertex attribute array specified by index. glDisableVertexAttribArray uses currently bound vertex array object for the operation,)[GL 4 only] By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as glDrawArrays or glDrawElements.

errors:
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
    GL_INVALID_OPERATION is generated if
        - no vertex array object is bound. [GL 4 only]

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS
    glGetVertexAttrib with arguments index and GL_VERTEX_ATTRIB_ARRAY_ENABLED
    glGetVertexAttribPointerv with arguments index and GL_VERTEX_ATTRIB_ARRAY_POINTER











glDrawArrays — render primitives from array data
    void glDrawArrays(GLenum mode, GLint first, GLsizei count);

mode
    Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, and GL_TRIANGLES are accepted. Limitation as per GL ES 2.0

first
    Specifies the starting index in the enabled arrays.

count
    Specifies the number of indices to be rendered.

glDrawArrays specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual (vertex attribute, you can use glVertexAttribPointer to)[GL ES 2.0]/(vertex, normal, texture coordinate, edge flag, or color, you can)[GL 2.1, GL 4] prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to glDrawArrays.

When glDrawArrays is called, it uses count sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element first. mode specifies what kind of primitives are constructed and how the array elements construct those primitives. (If GL_VERTEX_ARRAY is not enabled, no geometric primitives are generated.)[GL 2.1 only]

To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and glDisableVertexAttribArray. [GL ES 2.0 only]

Vertex attributes that are modified by glDrawArrays have an unspecified value after glDrawArrays returns. (For example, if GL_COLOR_ARRAY is enabled, the value of the current color is undefined after glDrawArrays executes.)[GL 2.1 only] Attributes that aren't modified remain well defined. [GL 2.1, GL 4]

Notes

If the current program object, as set by glUseProgram, is invalid, rendering results are undefined. However, no error is generated for this case. [GL ES 2.0 only]

glDrawArrays is included in display lists. If glDrawArrays is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed. [GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.
    GL_INVALID_VALUE is generated if
        - count is negative.
    GL_INVALID_OPERATION is generated if
        - a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. [GL 4 only]
    GL_INVALID_FRAMEBUFFER_OPERATION is generated if
        - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). [GL ES 2.0 only]





glDrawElements — render primitives from array data
    void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices);

mode
    Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, and GL_TRIANGLES are accepted. Limitation as per GL ES 2.0

count
    Specifies the number of elements to be rendered.

type
    Specifies the type of the values in indices. Must be GL_UNSIGNED_BYTE or GL_UNSIGNED_SHORT. Limitation as per GL ES 2.0

indices
    Specifies a pointer to the location where the indices are stored.

glDrawElements specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each (vertex attribute, you can use glVertexAttribPointer to prespecify separate arrays of vertex attributes)[GL ES 2.0]/(individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on,)[GL 2.1, GL 4] and use them to construct a sequence of primitives with a single call to glDrawElements.

When glDrawElements is called, it uses count sequential elements from an enabled array, starting at indices to construct a sequence of geometric primitives. mode specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used. (If GL_VERTEX_ARRAY is not enabled, no geometric primitives are constructed.)[GL 2.1 only]

To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and glDisableVertexAttribArray. [GL ES 2.0 only]

Vertex attributes that are modified by glDrawElements have an unspecified value after glDrawElements returns. (For example, if GL_COLOR_ARRAY is enabled, the value of the current color is undefined after glDrawElements executes.)[GL 2.1 only] Attributes that aren't modified maintain their previous values. [GL 2.1, GL 4]

Notes

If the current program object, as set by glUseProgram, is invalid, rendering results are undefined. However, no error is generated for this case. [GL ES 2.0 only]

glDrawElements is included in display lists. If glDrawElements is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed. [GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.
        - type is not GL_UNSIGNED_BYTE or GL_UNSIGNED_SHORT. [GL ES 2.0 only]
    GL_INVALID_VALUE is generated if
        - count is negative.
    GL_INVALID_OPERATION is generated if
        - a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. [GL 4 only]
    GL_INVALID_FRAMEBUFFER_OPERATION is generated if
        - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). [GL ES 2.0 only]








glFinish — block until all GL execution is complete
    void glFinish(void);

glFinish does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.

Notes

glFinish requires a round trip to the server.





glFlush — force execution of GL commands in finite time
    void glFlush(void);

Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. glFlush empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time.

Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call glFlush whenever they count on having all of their previously issued commands completed. For example, call glFlush before waiting for user input that depends on the generated image.

Notes

glFlush can return at any time. It does not wait until the execution of all previously issued GL commands is complete.





glFrontFace — define front- and back-facing polygons
    void glFrontFace(GLenum mode);

mode
    Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.

In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call glEnable and glDisable with argument GL_CULL_FACE.

The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. glFrontFace specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing GL_CCW to mode selects counterclockwise polygons as front-facing; GL_CW selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.

associated gets:
    glGet with argument GL_FRONT_FACE









glGenBuffers — generate buffer object names
    void glGenBuffers(GLsizei n, GLuint * buffers);

n:
    Specifies the number of buffer object names to be generated.

buffers:
    Specifies an array in which the generated buffer object names are stored.

glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenBuffers.

Buffer object names returned by a call to glGenBuffers are not returned by subsequent calls, unless they are first deleted with glDeleteBuffers.

No buffer objects are associated with the returned buffer object names until they are first bound by calling glBindBuffer.

errors:
    GL_INVALID_VALUE is generated if
        - n is negative.

associated gets:
    glIsBuffer




glGenTextures — generate texture names
    void glGenTextures(GLsizei n, GLuint * textures);

n:
    Specifies the number of texture names to be generated.

textures:
    Specifies an array in which the generated texture names are stored.

glGenTextures returns n texture names in textures. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenTextures.

The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see glBindTexture).

Texture names returned by a call to glGenTextures are not returned by subsequent calls, unless they are first deleted with glDeleteTextures.

errors:
    GL_INVALID_VALUE is generated if
        - n is negative.

associated gets:
    glIsTexture









glGet — return the value or values of a selected parameter
    void glGetBooleanv(GLenum pname, GLboolean * params);
    void glGetFloatv(GLenum pname, GLfloat * params);
    void glGetIntegerv(GLenum pname, GLint * params);

pname:
    Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.

params:
    Returns the value or values of the specified parameter.

These commands return values for simple state variables in GL. pname is a symbolic constant indicating the state variable to be returned, and params is a pointer to an array of the indicated type in which to place the returned data.

Type conversion is performed if params has a different type than the state variable value being requested. If glGetBooleanv is called, a floating-point (or integer) value is converted to GL_FALSE if and only if it is 0.0 (or 0). Otherwise, it is converted to GL_TRUE. If glGetIntegerv is called, boolean values are returned as GL_TRUE or GL_FALSE, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and -1.0 to the most negative representable integer value. If glGetFloatv is called, boolean values are returned as GL_TRUE or GL_FALSE, and integer values are converted to floating-point values.

The following symbolic constants are accepted by pname: Limitation as per GL ES 2.0, GL 2.1 and GL 4 core:

GL_ACTIVE_TEXTURE
    params returns a single value indicating the active multitexture unit. The initial value is GL_TEXTURE0. See glActiveTexture.

GL_ALIASED_LINE_WIDTH_RANGE
    params returns two values, the smallest and largest supported widths for aliased lines. (The range must include width 1.)[GL ES 2.0 only] (See glLineWidth.)[GL 4 only]

GL_ARRAY_BUFFER_BINDING
    params returns a single value, the name of the buffer object currently bound to the target GL_ARRAY_BUFFER. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See glBindBuffer.

GL_BLEND
    params returns a single boolean value indicating whether blending is enabled. The initial value is GL_FALSE. See glBlendFunc.

GL_BLEND_COLOR
    params returns four values, the red, green, blue, and alpha values which are the components of the blend color. See glBlendColor.

GL_BLEND_DST_ALPHA
    params returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is GL_ZERO. See glBlendFunc and glBlendFuncSeparate.

GL_BLEND_DST_RGB
    params returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is GL_ZERO. See glBlendFunc and glBlendFuncSeparate.

GL_BLEND_EQUATION_ALPHA
    params returns one value, a symbolic constant indicating whether the Alpha blend equation is GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT. Limitation as per GL ES 2.0. See glBlendEquationSeparate.

GL_BLEND_EQUATION_RGB
    params returns one value, a symbolic constant indicating whether the RGB blend equation is GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT. Limitation as per GL ES 2.0. See glBlendEquationSeparate.

GL_BLEND_SRC_ALPHA
    params returns one value, the symbolic constant identifying the alpha source blend function. The initial value is GL_ONE. See glBlendFunc and glBlendFuncSeparate.

GL_BLEND_SRC_RGB
    params returns one value, the symbolic constant identifying the RGB source blend function. The initial value is GL_ONE. See glBlendFunc and glBlendFuncSeparate.

GL_COLOR_CLEAR_VALUE
    params returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glClearColor.

GL_COLOR_WRITEMASK
    params returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is (GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE). See glColorMask.

GL_COMPRESSED_TEXTURE_FORMATS
    params returns a list of symbolic constants of length GL_NUM_COMPRESSED_TEXTURE_FORMATS indicating which compressed texture formats are available. See glCompressedTexImage2D.

GL_CULL_FACE
    params returns a single boolean value indicating whether polygon culling is enabled. The initial value is GL_FALSE. See glCullFace.

GL_CULL_FACE_MODE
    params returns one value, a symbolic constant indicating which polygon faces are to be culled. The initial value is GL_BACK. See glCullFace.

GL_CURRENT_PROGRAM
    params returns one value, the name of the program object that is currently active, or 0 if no program object is active. See glUseProgram.

GL_DEPTH_CLEAR_VALUE
    params returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See glClearDepth[f].

GL_DEPTH_FUNC
    params returns one value, the symbolic constant that indicates the depth comparison function. The initial value is GL_LESS. See glDepthFunc.

GL_DEPTH_RANGE
    params returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 1). See glDepthRange[f].

GL_DEPTH_TEST
    params returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is GL_FALSE. See glDepthFunc and glDepthRange[f].

GL_DEPTH_WRITEMASK
    params returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is GL_TRUE. See glDepthMask.

GL_DITHER
    params returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is GL_TRUE.

GL_ELEMENT_ARRAY_BUFFER_BINDING
    params returns a single value, the name of the buffer object currently bound to the target GL_ELEMENT_ARRAY_BUFFER. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See glBindBuffer.

GL_LINE_WIDTH
    params returns one value, the line width as specified with glLineWidth. The initial value is 1.

GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
    params returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 2 (as per GL 2.1). See glActiveTexture.

GL_MAX_CUBE_MAP_TEXTURE_SIZE
    params returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 16. ((If the GL version is 1.3 or greater,)[GL 2.1 only] use GL_PROXY_TEXTURE_CUBE_MAP to determine if a texture is too large.)[GL 2.1, GL 4] See glTexImage2D.

GL_MAX_TEXTURE_IMAGE_UNITS
    params returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 2 (as per GL 2.1). See glActiveTexture.

GL_MAX_TEXTURE_SIZE
    params returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 64. (If the GL version is 1.1 or greater, use GL_PROXY_TEXTURE_1D or GL_PROXY_TEXTURE_2D to determine if a texture is too large.)[GL 2.1 only] See glTexImage2D.

GL_MAX_VERTEX_ATTRIBS
    params returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 8 as per GL ES 2.0. See glVertexAttrib.

GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
    params returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be 0. See glActiveTexture.

GL_MAX_VIEWPORT_DIMS
    params returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See glViewport.

GL_NUM_COMPRESSED_TEXTURE_FORMATS
    params returns a single integer value indicating the number of available compressed texture formats. The minimum value is 0. See glCompressedTexImage2D.

GL_PACK_ALIGNMENT
    params returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See glPixelStore[i].

GL_POLYGON_OFFSET_FACTOR
    params returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.

GL_POLYGON_OFFSET_FILL
    params returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is GL_FALSE. See glPolygonOffset.

GL_POLYGON_OFFSET_UNITS
    params returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.

GL_SAMPLE_BUFFERS
    params returns a single integer value indicating the number of sample buffers associated with the (currently bound)[GL ES 2.0 only] framebuffer. See glSampleCoverage.

GL_SAMPLE_COVERAGE_INVERT
    params returns a single boolean value indicating if the temporary coverage value should be inverted. See glSampleCoverage.

GL_SAMPLE_COVERAGE_VALUE
    params returns a single positive floating-point value indicating the current sample coverage value. See glSampleCoverage.

GL_SAMPLES
    params returns a single integer value indicating the coverage mask size (of the currently bound framebuffer)[GL ES 2.0 only]. See glSampleCoverage.

GL_SCISSOR_BOX
    params returns four values: the x and y window coordinates of the scissor box, followed by its width and height. Initially the x and y window coordinates are both 0 and the width and height are set to the size of the window. See glScissor.

GL_SCISSOR_TEST
    params returns a single boolean value indicating whether scissoring is enabled. The initial value is GL_FALSE. See glScissor.

GL_STENCIL_BACK_FAIL
    params returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is GL_KEEP. See glStencilOpSeparate.

GL_STENCIL_BACK_FUNC
    params returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is GL_ALWAYS. See glStencilFuncSeparate.

GL_STENCIL_BACK_PASS_DEPTH_FAIL
    params returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is GL_KEEP. See glStencilOpSeparate.

GL_STENCIL_BACK_PASS_DEPTH_PASS
    params returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is GL_KEEP. See glStencilOpSeparate.

GL_STENCIL_BACK_REF
    params returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See glStencilFuncSeparate.

GL_STENCIL_BACK_VALUE_MASK
    params returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See glStencilFuncSeparate.

GL_STENCIL_BACK_WRITEMASK
    params returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See glStencilMaskSeparate.

GL_STENCIL_CLEAR_VALUE
    params returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See glClearStencil.

GL_STENCIL_FAIL
    params returns one value, a symbolic constant indicating what action is taken when the stencil test fails (for front-facing polygons and non-polygons.)[GL ES 2.0 only] The initial value is GL_KEEP. See glStencilOp (and)[GL ES 2.0]/((If the GL version is 2.0 or greater)[GL 2.1 only], this stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See)[GL 2.1, GL 4] glStencilOpSeparate.

GL_STENCIL_FUNC
    params returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value (for front-facing polygons and non-polygons.)[GL ES 2.0 only] The initial value is GL_ALWAYS. See glStencilFunc (and)[GL ES 2.0]/((If the GL version is 2.0 or greater)[GL 2.1 only], this stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See)[GL 2.1, GL 4] glStencilFuncSeparate.

GL_STENCIL_PASS_DEPTH_FAIL
    params returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails (for front-facing polygons and non-polygons.)[GL ES 2.0 only] The initial value is GL_KEEP. See glStencilOp (and)[GL ES 2.0]/((If the GL version is 2.0 or greater,)[GL 2.1 only] this stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See)[GL 2.1, GL 4] glStencilOpSeparate.

GL_STENCIL_PASS_DEPTH_PASS
    params returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes (for front-facing polygons and non-polygons.)[GL ES 2.0 only] The initial value is GL_KEEP. See glStencilOp (and)[GL ES 2.0]/((If the GL version is 2.0 or greater,)[GL 2.1 only] this stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See)[GL 2.1, GL 4] glStencilOpSeparate.

GL_STENCIL_REF
    params returns one value, the reference value that is compared with the contents of the stencil buffer (for front-facing polygons and non-polygons.)[GL ES 2.0 only] The initial value is 0. See glStencilFunc (and)[GL ES 2.0]/((If the GL version is 2.0 or greater,)[GL 2.1 only] this stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See)[GL 2.1, GL 4] glStencilFuncSeparate.

GL_STENCIL_TEST
    params returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is GL_FALSE. See glStencilFunc and glStencilOp.

GL_STENCIL_VALUE_MASK
    params returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared (for front-facing polygons and non-polygons.)[GL ES 2.0 only] The initial value is all 1's. See glStencilFunc (and)[GL ES 2.0]/((If the GL version is 2.0 or greater,)[GL 2.1 only] this stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See)[GL 2.1, GL 4] glStencilFuncSeparate.

GL_STENCIL_WRITEMASK
    params returns one value, the mask that controls writing of the stencil bitplanes (for front-facing polygons and non-polygons)[GL ES 2.0 only]. The initial value is all 1's. See glStencilMask (and)[GL ES 2.0]/((If the GL version is 2.0 or greater,)[GL 2.1 only] this stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See)[GL 2.1, GL 4] glStencilMaskSeparate.

GL_SUBPIXEL_BITS
    params returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.

GL_TEXTURE_BINDING_2D
    params returns a single value, the name of the texture currently bound to the target GL_TEXTURE_2D (for the active multitexture unit)[GL ES 2.0 only]. The initial value is 0. See glBindTexture.

GL_TEXTURE_BINDING_CUBE_MAP
    params returns a single value, the name of the texture currently bound to the target GL_TEXTURE_CUBE_MAP (for the active multitexture unit)[GL ES 2.0 only]. The initial value is 0. See glBindTexture.

GL_UNPACK_ALIGNMENT
    params returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See glPixelStore[i].

GL_VIEWPORT
    params returns four values: the x and y window coordinates of the viewport, followed by its width and height. Initially the x and y window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See glViewport.

Many of the boolean parameters can also be queried more easily using glIsEnabled.

Notes

The following parameters return the associated value for the active texture unit: GL_TEXTURE_2D, GL_TEXTURE_BINDING_2D [GL 4 only; also maybe misplaced for GL_TEXTURE_2D?]

errors:
    GL_INVALID_ENUM is generated if
        - pname is not (one of the values listed previously)[GL ES 2.0]/(an accepted value)[GL 2.1].











glGetActiveAttrib — return information about an active attribute variable (for the specified program object)[omitted in GL ES 2.0]
    void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length,
        GLint *size, GLenum *type, GLchar *name);

program:
    Specifies the program object to be queried.

index:
    Specifies the index of the attribute variable to be queried.

bufSize:
    Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.

length:
    Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.

size:
    Returns the size of the attribute variable.

type:
    Returns the data type of the attribute variable.

name:
    Returns a null terminated string containing the name of the attribute variable.

glGetActiveAttrib returns information about an active attribute variable in the program object specified by program. The number of active attributes can be obtained by calling glGetProgram[iv](only GL ES 2.0) with the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable. Permissible values for index range from 0 to the number of active attribute variables minus 1.

Attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, program should have previously been the target of a call to glLinkProgram, but it is not necessary for it to have been linked successfully. [GL ES 2.0]

A vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute variables have a prefix of "gl_" and reference conventional OpenGL vertex attribtes (e.g., gl_Vertex, gl_Normal, etc., see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, program should have previously been the target of a call to glLinkProgram, but it is not necessary for it to have been linked successfully. [GL 2.1, GL 4].


The size of the character buffer required to store the longest attribute variable name in program can be obtained by calling glGetProgram[iv](only GL ES 2.0) with the value GL_ACTIVE_ATTRIBUTE_MAX_LENGTH. This value should be used to allocate a buffer of sufficient size to store the returned attribute name. The size of this character buffer is passed in bufSize, and a pointer to this character buffer is passed in name.

glGetActiveAttrib returns the name of the attribute variable indicated by index, storing it in the character buffer specified by name. The string returned will be null terminated. The actual number of characters written into this buffer is returned in length, and this count does not include the null termination character. If the length of the returned string is not required, a value of NULL can be passed in the length argument.

The type argument will return a pointer to the attribute variable's data type. The symbolic constants GL_FLOAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_FLOAT_MAT2, GL_FLOAT_MAT3, or GL_FLOAT_MAT4 (Limitation as per GL ES 2.0) may be returned. The size argument will return the size of the attribute, in units of the type returned in type.

The list of active attribute variables may include both built-in attribute variables (which begin with the prefix "gl_") as well as user-defined attribute variable names. [GL 2.1, GL 4]

This function will return as much information as it can about the specified active attribute variable. If no information is available, length will be 0, and name will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values length, size, type, and name will be unmodified.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
        - index is greater than or equal to the number of active attribute variables in program.
        - bufSize is less than 0.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS.
    glGetProgram[iv](only GL ES 2.0) with argument GL_ACTIVE_ATTRIBUTES or GL_ACTIVE_ATTRIBUTE_MAX_LENGTH.
    glIsProgram











glGetActiveUniform — return information about an active uniform variable (for the specified program object)[omitted in GL ES 2.0]
    void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length,
        GLint *size, GLenum *type, GLchar *name);

program:
    Specifies the program object to be queried.

index:
    Specifies the index of the uniform variable to be queried.

bufSize:
    Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.

length:
    Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.

size:
    Returns the size of the uniform variable.

type:
    Returns the data type of the uniform variable.

name:
    Returns a null terminated string containing the name of the uniform variable.


glGetActiveUniform returns information about an active uniform variable in the program object specified by program. The number of active uniform variables can be obtained by calling glGetProgram[iv] with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable. Permissible values for index range from 0 to the number of active uniform variables minus 1.

Shaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables have a prefix of "gl_" and reference existing OpenGL state or values derived from such state (e.g., (gl_DepthRange)[GL ES 2.0]/((gl_Fog, gl_ModelViewMatrix, etc.)[GL 2.1]/(gl_DepthRangeParameters)[GL 4], see the OpenGL Shading Language specification for a complete list.)[GL 2.1, GL 4]). User-defined uniform variables have arbitrary names and obtain their values from the application through calls to glUniform. A uniform variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, program should have previously been the target of a call to glLinkProgram, but it is not necessary for it to have been linked successfully.

The size of the character buffer required to store the longest uniform variable name in program can be obtained by calling glGetProgram[iv] with the value GL_ACTIVE_UNIFORM_MAX_LENGTH. This value should be used to allocate a buffer of sufficient size to store the returned uniform variable name. The size of this character buffer is passed in bufSize, and a pointer to this character buffer is passed in name.

glGetActiveUniform returns the name of the uniform variable indicated by index, storing it in the character buffer specified by name. The string returned will be null terminated. The actual number of characters written into this buffer is returned in length, and this count does not include the null termination character. If the length of the returned string is not required, a value of NULL can be passed in the length argument.

The type argument will return a pointer to the uniform variable's data type. The symbolic constants GL_FLOAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_INT, GL_INT_VEC2, GL_INT_VEC3, GL_INT_VEC4, GL_BOOL, GL_BOOL_VEC2, GL_BOOL_VEC3, GL_BOOL_VEC4, GL_FLOAT_MAT2, GL_FLOAT_MAT3, GL_FLOAT_MAT4, GL_SAMPLER_2D, or GL_SAMPLER_CUBE may be returned. (Limitation as per GL ES 2.0) (representation of "Shader Uniform Type" according to GL 4 to be, in order: float, vec2, vec3, vec4, int, ivec2, ivec3, ivec4, bool, bvec2, bvec3, bvec4, mat2, mat3, mat4, sampler2D, samplerCube)

If one or more elements of an array are active, the name of the array is returned in name, the type is returned in type, and the size parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will be reported for a uniform array.

Uniform variables that are declared as structures or arrays of structures will not be returned directly by this function. Instead, each of these uniform variables will be reduced to its fundamental components containing the "." and "[]" operators such that each of the names is valid as an argument to glGetUniformLocation. Each of these reduced uniform variables is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of structures, or a subcomponent of a vector or matrix.

The size of the uniform variable will be returned in size. Uniform variables other than arrays will have a size of 1. Structures and arrays of structures will be reduced as described earlier, such that each of the names returned will be a data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform arrays; otherwise, the size returned will be 1.

The list of active uniform variables may include both built-in uniform variables (which begin with the prefix "gl_") as well as user-defined uniform variable names.

This function will return as much information as it can about the specified active uniform variable. If no information is available, length will be 0, and name will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values length, size, type, and name will be unmodified.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
        - index is greater than or equal to the number of active uniform variables in program.
        - bufSize is less than 0.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.

associated gets:
    glGet with argument GL_MAX_VERTEX_UNIFORM_VECTORS or GL_MAX_FRAGMENT_UNIFORM_VECTORS. [GL ES 2.0 only]
    glGet with argument GL_MAX_VERTEX_UNIFORM_COMPONENTS or GL_MAX_FRAGMENT_UNIFORM_COMPONENTS. [GL 2.1, GL 4]
    glGetProgram[iv] with argument GL_ACTIVE_UNIFORMS or GL_ACTIVE_UNIFORM_MAX_LENGTH.
    glIsProgram







glGetAttachedShaders — return the handles of the shader objects attached to a program object
    void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);

program:
    Specifies the program object to be queried.

maxCount:
    Specifies the size of the array for storing the returned object names.

count:
    Returns the number of names actually returned in shaders.

shaders:
    Specifies an array that is used to return the names of attached shader objects.

glGetAttachedShaders returns the names of the shader objects attached to program. The names of shader objects that are attached to program will be returned in shaders. The actual number of shader names written into shaders is returned in count. If no shader objects are attached to program, count is set to 0. The maximum number of shader names that may be returned in shaders is specified by maxCount.

If the number of names actually returned is not required (for instance, if it has just been obtained by calling glGetProgram[iv]), a value of NULL may be passed for count. If no shader objects are attached to program, a value of 0 will be returned in count. The actual number of attached shaders can be obtained by calling glGetProgram[iv] with the value GL_ATTACHED_SHADERS.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
        - maxCount is less than 0.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.

associated gets:
    glGetProgram[iv] with argument GL_ATTACHED_SHADERS
    glIsProgram







glGetAttribLocation — return the location of an attribute variable
    GLint glGetAttribLocation(GLuint program, const GLchar *name);

program:
    Specifies the program object to be queried.

name:
    Points to a null terminated string containing the name of the attribute variable whose location is to be queried.

glGetAttribLocation queries the previously linked program object specified by program for the attribute variable specified by name and returns the index of the generic vertex attribute that is bound to that attribute variable. If name is a matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is not an active attribute in the specified program object or if name starts with the reserved prefix "gl_", a value of -1 is returned.

The association between an attribute variable name and a generic attribute index can be specified at any time by calling glBindAttribLocation. Attribute bindings do not go into effect until glLinkProgram is called. After a program object has been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The attribute values can only be queried after a link if the link was successful. glGetAttribLocation returns the binding that actually went into effect the last time glLinkProgram was called for the specified program object. Attribute bindings that have been specified since the last link operation are not returned by glGetAttribLocation.

errors:
    GL_INVALID_OPERATION is generated if
        - program is not a value generated by OpenGL.
        - program is not a program object.
        - program has not been successfully linked.

associated gets:
    glGetActiveAttrib with argument program and the index of an active attribute
    glIsProgram












glGetBufferParameteriv — return parameters of a buffer object
    void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data);

target:
    Specifies the target (buffer object)[GL ES 2.0, GL 2.1]/(to which the buffer object is bound)[GL 4]. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER. (Purpose as per GL 4: Vertex attributes or Vertex array indices respectively) Limitation as per GL ES 2.0

value:
    Specifies the symbolic name of a buffer object parameter (to query.)[GL 4 only]. Accepted values are GL_BUFFER_SIZE or GL_BUFFER_USAGE. Limitation as per GL ES 2.0

data:
    Returns the requested parameter.

glGetBufferParameteriv returns in data a selected parameter of the buffer object specified by target.

value names a specific buffer object parameter, as follows: (Limitation as per GL ES 2.0)

GL_BUFFER_SIZE
    params returns the size of the buffer object, measured in bytes. The initial value is 0.

GL_BUFFER_USAGE
    params returns the buffer object's usage pattern. The initial value is GL_STATIC_DRAW.

Notes

If an error is generated, no change is made to the contents of data.

errors:
    GL_INVALID_ENUM is generated if
        - target or value is not an accepted value.
    GL_INVALID_OPERATION is generated if
        - the reserved buffer object name 0 is bound to target.










glGetError — return error information
    GLenum glGetError(void);

glGetError returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until glGetError is called, the error code is returned, and the flag is reset to GL_NO_ERROR. If a call to glGetError returns GL_NO_ERROR, there has been no detectable error since the last call to glGetError, or since the GL was initialized.

To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to GL_NO_ERROR when glGetError is called. If more than one flag has recorded an error, glGetError returns and clears an arbitrary error flag value. Thus, glGetError should always be called in a loop, until it returns GL_NO_ERROR, if all error flags are to be reset.

Initially, all error flags are set to GL_NO_ERROR.

The following errors are currently defined:

GL_NO_ERROR
    No error has been recorded. The value of this symbolic constant is guaranteed to be 0.

GL_INVALID_ENUM
    An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.

GL_INVALID_VALUE
    A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.

GL_INVALID_OPERATION
    The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.

GL_INVALID_FRAMEBUFFER_OPERATION [GL ES 2.0, GL 4]
    (The command is trying to render to or read from the framebuffer while the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE).)[GL ES 2.0]/(The framebuffer object is not complete.)[GL 4] The offending command is ignored and has no other side effect than to set the error flag.

GL_STACK_OVERFLOW [GL 2.1, GL 4]
    (This command would cause a stack overflow. The offending command is ignored and has no other side effect than to set the error flag.)[GL 2.1]/(An attempt has been made to perform an operation that would cause an internal stack to overflow.)[GL 4]

GL_STACK_UNDERFLOW [GL 2-1, GL 4]
    (This command would cause a stack underflow. The offending command is ignored and has no other side effect than to set the error flag.)[GL 2.1]/(An attempt has been made to perform an operation that would cause an internal stack to underflow.)[GL 4]

GL_OUT_OF_MEMORY
    There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.

GL_TABLE_TOO_LARGE [GL 2.1 only]
    The specified table exceeds the implementation's maximum supported table size. The offending command is ignored and has no other side effect than to set the error flag.

When an error flag is set, results of a GL operation are undefined only if GL_OUT_OF_MEMORY has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. (If glGetError itself generates an error, it returns 0. )[GL 2.1 only; only for glBegin/glEnd; but sentence still there for GL 4]



    .





glGetProgramInfoLog — return the information log for a program object
    void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog);

program:
    Specifies the program object whose information log is to be queried.

maxLength:
    Specifies the size of the character buffer for storing the returned information log.

length:
    Returns the length of the string returned in infoLog (excluding the null terminator).

infoLog:
    Specifies an array of characters that is used to return the information log.

glGetProgramInfoLog returns the information log for the specified program object. The information log for a program object is modified when the program object is linked or validated. The string that is returned will be null terminated.

glGetProgramInfoLog returns in infoLog as much of the information log as it can, up to a maximum of maxLength characters. The number of characters actually returned, excluding the null termination character, is specified by length. If the length of the returned string is not required, a value of NULL can be passed in the length argument. The size of the buffer required to store the returned information log can be obtained by calling glGetProgram[iv] with the value GL_INFO_LOG_LENGTH.

The information log for a program object is either an empty string, or a string containing information about the last link operation, or a string containing information about the last validation operation. It may contain diagnostic messages, warning messages, and other information. When a program object is created, its information log will be a string of length 0.

Notes

The information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking and validating. Therefore, the information log can be helpful to application developers during the development process, even when these operations are successful. Application developers should not expect different OpenGL implementations to produce identical information logs.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
        - maxLength is less than 0.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.

associated gets:
    glGetProgram[iv] with argument GL_INFO_LOG_LENGTH
    glIsProgram















glGetProgramiv — return a parameter from a program object
    void glGetProgramiv(GLuint program, GLenum pname, GLint *params);

program:
    Specifies the program object to be queried.

pname:
    Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH. Limitation as per GL ES 2.0 and GL 2.1

params
    Returns the requested object parameter.

glGetProgram[iv] returns in params the value of a parameter for a specific program object. The following parameters are defined:

GL_DELETE_STATUS
    params returns GL_TRUE if program is currently flagged for deletion, and GL_FALSE otherwise.

GL_LINK_STATUS
    params returns GL_TRUE if the last link operation on program was successful, and GL_FALSE otherwise.

GL_VALIDATE_STATUS
    params returns GL_TRUE or if the last validation operation on program was successful, and GL_FALSE otherwise.

GL_INFO_LOG_LENGTH
    params returns the number of characters in the information log for program including the null termination character (i.e., the size of the character buffer required to store the information log). If program has no information log, a value of 0 is returned.

GL_ATTACHED_SHADERS
    params returns the number of shader objects attached to program.

GL_ACTIVE_ATTRIBUTES
    params returns the number of active attribute variables for program.

GL_ACTIVE_ATTRIBUTE_MAX_LENGTH
    params returns the length of the longest active attribute name for program, including the null termination character (i.e., the size of the character buffer required to store the longest attribute name). If no active attributes exist, 0 is returned.

GL_ACTIVE_UNIFORMS
    params returns the number of active uniform variables for program.

GL_ACTIVE_UNIFORM_MAX_LENGTH
    params returns the length of the longest active uniform variable name for program, including the null termination character (i.e., the size of the character buffer required to store the longest uniform variable name). If no active uniform variables exist, 0 is returned.

Notes

If an error is generated, no change is made to the contents of params.

errors:
    GL_INVALID_ENUM is generated if
        - pname is not an accepted value.
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program does not refer to a program object.

associated gets:
    glGetActiveAttrib with argument program
    glGetActiveUniform with argument program
    glGetAttachedShaders with argument program
    glGetProgramInfoLog with argument program
    glIsProgram



























glGetShaderInfoLog — return the information log for a shader object
    void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog);

shader:
    Specifies the shader object whose information log is to be queried.

maxLength:
    Specifies the size of the character buffer for storing the returned information log.

length:
    Returns the length of the string returned in infoLog (excluding the null terminator).

infoLog:
    Specifies an array of characters that is used to return the information log.

glGetShaderInfoLog returns the information log for the specified shader object. The information log for a shader object is modified when the shader is compiled. The string that is returned will be null terminated.

glGetShaderInfoLog returns in infoLog as much of the information log as it can, up to a maximum of maxLength characters. The number of characters actually returned, excluding the null termination character, is specified by length. If the length of the returned string is not required, a value of NULL can be passed in the length argument. The size of the buffer required to store the returned information log can be obtained by calling glGetShader[iv] with the value GL_INFO_LOG_LENGTH.

The information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information about the last compile operation. When a shader object is created, its information log will be a string of length 0.

Notes

The information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the compilation process. Therefore, the information log can be helpful to application developers during the development process, even when compilation is successful. Application developers should not expect different OpenGL implementations to produce identical information logs.

errors:
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.
        - maxLength is less than 0.
    GL_INVALID_OPERATION is generated if
        - shader is not a shader object.

associated gets:
    glGetShader[iv] with argument GL_INFO_LOG_LENGTH
    glIsShader









glGetShaderSource — return the source code string from a shader object
    void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);

shader:
    Specifies the shader object to be queried.

bufSize:
    Specifies the size of the character buffer for storing the returned source code string.

length:
    Returns the length of the string returned in source (excluding the null terminator).

source:
    Specifies an array of characters that is used to return the source code string.

glGetShaderSource returns the concatenation of the source code strings from the shader object specified by shader. The source code strings for a shader object are the result of a previous call to glShaderSource. The string returned by the function will be null terminated.

glGetShaderSource returns in source as much of the source code string as it can, up to a maximum of bufSize characters. The number of characters actually returned, excluding the null termination character, is specified by length. If the length of the returned string is not required, a value of NULL can be passed in the length argument. The size of the buffer required to store the returned source code string can be obtained by calling glGetShader[iv] with the value GL_SHADER_SOURCE_LENGTH.

errors:
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.
        - bufSize is less than 0.
    GL_INVALID_OPERATION is generated if
        - shader is not a shader object.

associated gets:
    glGetShader[iv] with argument GL_SHADER_SOURCE_LENGTH
    glIsShader









glGetShaderiv — return a parameter from a shader object
    void glGetShaderiv(GLuint shader, GLenum pname, GLint *params);

shader:
    Specifies the shader object to be queried.

pname:
    Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.

params:
    Returns the requested object parameter.

glGetShader[iv] returns in params the value of a parameter for a specific shader object. The following parameters are defined:

GL_SHADER_TYPE
    params returns GL_VERTEX_SHADER if shader is a vertex shader object, (GL_GEOMETRY_SHADER if shader is a geometry shader object,)[GL 4 only] and GL_FRAGMENT_SHADER if shader is a fragment shader object.

GL_DELETE_STATUS
    params returns GL_TRUE if shader is currently flagged for deletion, and GL_FALSE otherwise.

GL_COMPILE_STATUS
    (For implementations that support a shader compiler,)[GL ES 2.0 only] params returns GL_TRUE if the last compile operation on shader was successful, and GL_FALSE otherwise.

GL_INFO_LOG_LENGTH
    (For implementations that support a shader compiler,)[GL ES 2.0 only] params returns the number of characters in the information log for shader including the null termination character (i.e., the size of the character buffer required to store the information log). If shader has no information log, a value of 0 is returned.

GL_SHADER_SOURCE_LENGTH
    (For implementations that support a shader compiler,)[GL ES 2.0 only] params returns the length of the concatenation of the source strings that make up the shader source for the shader, including the null termination character. (i.e., the size of the character buffer required to store the shader source). If no source code exists, 0 is returned.

Notes

(Shader compiler support is optional, and thus must be queried before use by calling glGet with argument GL_SHADER_COMPILER. glShaderSource, glCompileShader, glGetShaderPrecisionFormat, and glReleaseShaderCompiler will each generate GL_INVALID_OPERATION on implementations that do not support a shader compiler, as will glGetShaderiv queries of GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, and GL_SHADER_SOURCE_LENGTH. Such implementations instead offer the glShaderBinary alternative for supplying a pre-compiled shader binary. )[GL ES 2.0 only]

If an error is generated, no change is made to the contents of params.

errors:
    GL_INVALID_ENUM is generated if
        - pname is not an accepted value.
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - pname is GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, or GL_SHADER_SOURCE_LENGTH but a shader compiler is not supported. [GL ES 2.0 only]
        - shader does not refer to a shader object.

associated gets:
    glGet with argument GL_SHADER_COMPILER [GL ES 2.0 only]
    glGetShaderInfoLog with argument shader
    glGetShaderSource with argument shader
    glIsShader












glGetString — return a string describing the current GL connection
    const GLubyte* glGetString(GLenum name);

name:
    Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION or GL_SHADING_LANGUAGE_VERSION. Limitation as per GL 4 core profile

glGetString returns a pointer to a static string describing some aspect of the current GL connection. name can be one of the following:

GL_VENDOR
    Returns the company responsible for this GL implementation. This name does not change from release to release.

GL_RENDERER
    Returns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.

GL_VERSION
    Returns a version or release number (of the form OpenGL<space>ES<space><version number><space><vendor-specific information>.)[GL ES 2.0 only]

GL_SHADING_LANGUAGE_VERSION
    Returns a version or release number for the shading language (of the form OpenGL<space>ES<space>GLSL<space>ES<space><version number><space><vendor-specific information>.)[GL ES 2.0 only]

(Because the GL does not include queries for the performance characteristics of an implementation, some applications are written to recognize known platforms and modify their GL usage based on known performance characteristics of these platforms.)[GL ES 2.0, GL 2.1] Strings GL_VENDOR and GL_RENDERER together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms.

S(ome applications want to make use of features that are not part of the standard GL. These features may be implemented as extensions to the standard GL. The GL_EXTENSIONS string is a space-separated list of supported GL extensions. (Extension names never contain a space character.))[GL ES 2.0, GL 2.1]

(The GL_VERSION and GL_SHADING_LANGUAGE_VERSION strings begin with a version number. The version number uses one of these forms:

major_number.minor_number major_number.minor_number.release_number

Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information.)[GL 2.1, GL 4]

All strings are null-terminated.

Notes

If an error is generated, glGetString returns 0.

The client and server may support different versions (or extensions)[GL ES 2.0, GL 2.1]. glGetString always returns a compatible version number (or list of extensions)[GL ES 2.0, GL 2.1]. The release number always describes the server.

errors:
    GL_INVALID_ENUM is generated if
        - name is not an accepted value.
























glGetTexParameter — return texture parameter values
    void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params);
    void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params);

target:
    Specifies the (symbolic name of the target texture (of the active texture unit)[GL ES 2.0 only])[GL ES 2.0, GL 2.1]/(target to which the texture is bound)[GL 4]. GL_TEXTURE_2D and GL_TEXTURE_CUBE_MAP are accepted. Limitation as per GL ES 2.0

pname:
    Specifies the symbolic name of a texture parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_WRAP_S, and GL_TEXTURE_WRAP_T are accepted. Limitation as per GL ES 2.0.

params:
    Returns the texture parameter.

glGetTexParameter returns in params the value of the texture parameter specified as pname. target defines the target texture (of the active texture unit)[GL ES 2.0 only], either GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP, to specify two-dimensional or cube-mapped texturing. pname accepts the same symbols as glTexParameter, with the same interpretations:

GL_TEXTURE_MAG_FILTER
    Returns the single-valued texture magnification filter, a symbolic constant. The initial value is GL_LINEAR.

GL_TEXTURE_MIN_FILTER
    Returns the single-valued texture minification filter, a symbolic constant. The initial value is GL_NEAREST_MIPMAP_LINEAR.

GL_TEXTURE_WRAP_S
    Returns the single-valued wrapping function for texture coordinate s, a symbolic constant. The initial value is GL_REPEAT.

GL_TEXTURE_WRAP_T
    Returns the single-valued wrapping function for texture coordinate t, a symbolic constant. The initial value is GL_REPEAT.

Notes

If an error is generated, no change is made to the contents of params.

errors:
    GL_INVALID_ENUM is generated if
        - target or pname is not an accepted value.










glGetUniform — return the value of a uniform variable
    void glGetUniformfv(GLuint program, GLint location, GLfloat *params);
    void glGetUniformiv(GLuint program, GLint location, GLint *params);

program:
    Specifies the program object to be queried.

location:
    Specifies the location of the uniform variable to be queried.

params:
    Returns the value of the specified uniform variable.

glGetUniform returns in params the value(s) of the specified uniform variable. The type of the uniform variable specified by location determines the number of values returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values stored in uniform variables declared as arrays, call glGetUniform for each element of the array. To query values stored in uniform variables declared as structures, call glGetUniform for each field in the structure. The values for uniform variables declared as a matrix will be returned in column major order.

The locations assigned to uniform variables are not known until the program object is linked. After linking has occurred, the command glGetUniformLocation can be used to obtain the location of a uniform variable. This location value can then be passed to glGetUniform in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. The uniform variable values can only be queried after a link if the link was successful.

Notes

If an error is generated, no change is made to the contents of params.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - program has not been successfully linked.
        - location does not correspond to a valid uniform variable location for the specified program object.

associated gets:
    glGetActiveUniform with arguments program and the index of an active uniform variable
    glGetProgram[iv] with arguments program and GL_ACTIVE_UNIFORMS or GL_ACTIVE_UNIFORM_MAX_LENGTH
    glGetUniformLocation with arguments program and the name of a uniform variable
    glIsProgram















glGetUniformLocation — return the location of a uniform variable
    GLint glGetUniformLocation(GLuint program, const GLchar *name);

program:
    Specifies the program object to be queried.

name:
    Points to a null terminated string containing the name of the uniform variable whose location is to be queried.

glGetUniformLocation returns an integer that represents the location of a specific uniform variable within a program object. name must be a null terminated string that contains no white space. name must be an active uniform variable name in program that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if name does not correspond to an active uniform variable in program or if name starts with the reserved prefix "gl_". (, or if name is associated with an atomic counter or a named uniform block)[GL 4 only]

Uniform variables that are structures or arrays of structures may be queried by calling glGetUniformLocation for each field within the structure. The array element operator "[]" and the structure field operator "." may be used in name in order to select elements within an array or fields within a structure. The result of using these operators is not allowed to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of name indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name of the array, or by using the name appended by "[0]".

The actual locations assigned to uniform variables are not known until the program object is linked successfully. After linking has occurred, the command glGetUniformLocation can be used to obtain the location of a uniform variable. This location value can then be passed to glUniform to set the value of the uniform variable or to glGetUniform in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried after a link if the link was successful.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - program has not been successfully linked.

associated gets:
    glGetActiveUniform with arguments program and the index of an active uniform variable
    glGetProgram[iv] with arguments program and GL_ACTIVE_UNIFORMS or GL_ACTIVE_UNIFORM_MAX_LENGTH
    glGetUniform with arguments program and the name of a uniform variable
    glIsProgram
















glGetVertexAttrib — return a generic vertex attribute parameter
    void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params);
    void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params);

index
    Specifies the generic vertex attribute parameter to be queried.

pname
    Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB. Limitation as per GL ES 2.0 and GL 2.1

params
    Returns the requested data.

glGetVertexAttrib returns in params the value of a generic vertex attribute parameter. The generic vertex attribute to be queried is specified by index, and the parameter to be queried is specified by pname.

The accepted parameter names are as follows:

GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
    params returns a single value, the name of the buffer object currently bound to the binding point corresponding to generic vertex attribute array index. If no buffer object is bound, 0 is returned. The initial value is 0.

GL_VERTEX_ATTRIB_ARRAY_ENABLED
    params returns a single value that is non-zero (true) if the vertex attribute array for index is enabled and 0 (false) if it is disabled. The initial value is GL_FALSE.

GL_VERTEX_ATTRIB_ARRAY_SIZE
    params returns a single value, the size of the vertex attribute array for index. The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3, or 4. The initial value is 4.

GL_VERTEX_ATTRIB_ARRAY_STRIDE
    params returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for index. A value of 0 indicates that the array elements are stored sequentially in memory. The initial value is 0.

GL_VERTEX_ATTRIB_ARRAY_TYPE
    params returns a single value, a symbolic constant indicating the array type for the vertex attribute array for index. Possible values are GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, (GL_FIXED)[GL ES 2.0 only], (and GL_FLOAT.)[GL ES 2.0]/(GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE.)[GL 2.1, GL 4] The initial value is GL_FLOAT.

GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
    params returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index are normalized when they are converted to floating point, and 0 (false) otherwise. The initial value is GL_FALSE.

GL_CURRENT_VERTEX_ATTRIB
    params returns four values that represent the current value for the generic vertex attribute specified by index. (The initial value is (0,0,0,1).)[GL ES 2.0]/(Generic vertex attribute 0 is unique in that it has no current state, so an error will be generated if index is 0. The initial value for all other generic vertex attributes is (0,0,0,1).)[GL 2.1, GL 4]

    glGetVertexAttribfv returns the current attribute values as four single-precision floating-point values; glGetVertexAttribiv reads them as floating-point values and converts them to four integer values [GL 4 only]

All of the parameters except GL_CURRENT_VERTEX_ATTRIB represent (client-side state)[GL ES 2.0, GL 2.1]/(state stored in the currently bound vertex array object)[GL 4].

Notes

If an error is generated, no change is made to the contents of params.

errors:
    GL_INVALID_ENUM is generated if
        - pname is not an accepted value.
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
    GL_INVALID_OPERATION is generated if
        - index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB. [GL 2.1, GL 4]
        - pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object. [GL 4 only]

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS
    glGetVertexAttribPointerv with arguments index and GL_VERTEX_ATTRIB_ARRAY_POINTER














glGetVertexAttribPointerv — return the address of the specified generic vertex attribute pointer
    void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer);

index:
    Specifies the generic vertex attribute parameter to be returned.

pname:
    Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.

pointer:
    Returns the pointer value.

glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be queried, pname is a symbolic constant indicating the pointer to be returned, and params is a pointer to a location in which to place the returned data.

(If a non-zero named buffer object was bound to the GL_ARRAY_BUFFER target (see glBindBuffer) when the desired pointer was previously specified, the pointer returned is a byte offset into the buffer object's data store.)[GL ES 2.0, GL 2.1]/(The pointer returned is a byte offset into the data store of the buffer object that was bound to the GL_ARRAY_BUFFER target (see glBindBuffer) when the desired pointer was previously specified.)[GL 4]

Notes

(The pointer returned is client-side state.)[GL ES 2.0, GL 2.1]/(The state returned is retrieved from the currently bound vertex array object.)[GL 4]

The initial value for each pointer is 0.

errors:
    GL_INVALID_ENUM is generated if
        - pname is not an accepted value.
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
    GL_INVALID_OPERATION is generated if
        - no vertex array object is currently bound. [GL 4 only]

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS






glHint — specify implementation-specific hints
    void glHint(GLenum target, GLenum mode);

target
    Specifies a symbolic constant indicating the behavior to be controlled. [None] is accepted. Limitation as per GL ES 2.0 and GL 4. [function effectively useless]

mode
    Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.

Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. target is a symbolic constant indicating the behavior to be controlled, and mode is another symbolic constant indicating the desired behavior. The initial value for each target is GL_DONT_CARE. mode can be one of the following:

GL_FASTEST
    The most efficient option should be chosen.

GL_NICEST
    The most correct, or highest quality, option should be chosen.

GL_DONT_CARE
    No preference.

Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with target, along with suggested semantics, are as follows:

[None left]

Notes

The interpretation of hints depends on the implementation. Some implementations ignore glHint settings.

errors:
    GL_INVALID_ENUM is generated if
        - either target or mode is not an accepted value.







glIsBuffer — determine if a name corresponds to a buffer object
    GLboolean glIsBuffer(GLuint buffer);

buffer:
    Specifies a value that may be the name of a buffer object.

glIsBuffer returns GL_TRUE if buffer is currently the name of a buffer object. If buffer is zero, or is a non-zero value that is not currently the name of a buffer object, or if an error occurs, glIsBuffer returns GL_FALSE.

A name returned by glGenBuffers, but not yet associated with a buffer object by calling glBindBuffer, is not the name of a buffer object.




glIsEnabled — test whether a capability is enabled
    GLboolean glIsEnabled(GLenum cap);

cap:
    Specifies a symbolic constant indicating a GL capability.

glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Initially all capabilities except GL_DITHER are disabled; GL_DITHER is initially enabled.

The following capabilities are accepted for cap: [Limitation as per GL ES 2.0]

Constant                      See
GL_BLEND                      glBlendFunc, [glLogicOp](GL 2.1, GL 4)
GL_CULL_FACE                  glCullFace
GL_DEPTH_TEST                 glDepthFunc, glDepthRange[f]
GL_DITHER                     glEnable
GL_POLYGON_OFFSET_FILL        glPolygonOffset
GL_SAMPLE_ALPHA_TO_COVERAGE   glSampleCoverage
GL_SAMPLE_COVERAGE            glSampleCoverage
GL_SCISSOR_TEST               glScissor
GL_STENCIL_TEST               glStencilFunc, glStencilOp

Notes

If an error is generated, glIsEnabled returns (0)[GL ES 2.0, GL 2.1]/(GL_FALSE)[GL 4].

errors:
    GL_INVALID_ENUM is generated if
        - cap is not an accepted value.







glIsProgram — determine if a name corresponds to a program object
    GLboolean glIsProgram(GLuint program);

program:
    Specifies a potential program object.

glIsProgram returns GL_TRUE if program is the name of a program object previously created with glCreateProgram and not yet deleted with glDeleteProgram. If program is zero or a non-zero value that is not the name of a program object, or if an error occurs, glIsProgram returns GL_FALSE.

Notes

No error is generated if program is not a valid program object name.

A program object marked for deletion with glDeleteProgram but still in use as part of current rendering state is still considered a program object and glIsProgram will return GL_TRUE.

associated gets: [GL 2.1, GL 4]
    glGet with the argument GL_CURRENT_PROGRAM
    glGetActiveAttrib with arguments program and the index of an active attribute variable
    glGetActiveUniform with arguments program and the index of an active uniform variable
    glGetAttachedShaders with argument program
    glGetAttribLocation with arguments program and the name of an attribute variable
    glGetProgram with arguments program and the parameter to be queried
    glGetProgramInfoLog with argument program
    glGetUniform with arguments program and the location of a uniform variable
    glGetUniformLocation with arguments program and the name of a uniform variable











glIsShader — determine if a name corresponds to a shader object
    GLboolean glIsShader(GLuint shader);

shader:
    Specifies a potential shader object.

glIsShader returns GL_TRUE if shader is the name of a shader object previously created with glCreateShader and not yet deleted with glDeleteShader. If shader is zero or a non-zero value that is not the name of a shader object, or if an error occurs, glIsShader returns GL_FALSE.

Notes

No error is generated if shader is not a valid shader object name.

A shader object marked for deletion with glDeleteShader but still attached to a program object is still considered a shader object and glIsShader will return GL_TRUE.

associated gets: [GL 2.1, GL 4]
    glGetAttachedShaders with a valid program object
    glGetShader with arguments shader and a parameter to be queried
    glGetShaderInfoLog with argument object
    glGetShaderSource with argument object











glIsTexture — determine if a name corresponds to a texture
    GLboolean glIsTexture(GLuint texture);

texture:
    Specifies a value that may be the name of a texture.

glIsTexture returns GL_TRUE if texture is currently the name of a texture. If texture is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, glIsTexture returns GL_FALSE.

A name returned by glGenTextures, but not yet associated with a texture by calling glBindTexture, is not the name of a texture.

























glLineWidth — specify the width of rasterized lines
    void glLineWidth(GLfloat width);

width:
    Specifies the width of rasterized lines. The initial value is 1.

glLineWidth specifies the rasterized width of (both aliased and antialiased)[omitted in GL ES 2.0] lines. (Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call glEnable and glDisable with argument GL_LINE_SMOOTH. Line antialiasing is initially disabled.)[omitted in GL ES 2.0]

(If line antialiasing is disabled,)[omitted in GL ES 2.0] The actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If ∣Δx∣>=∣Δy∣ , i pixels are filled in each column that is rasterized, where i is the rounded value of width. Otherwise, i pixels are filled in each row that is rasterized.

(If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step.)[omitted in GL ES 2.0]

(There is a range of supported line widths. Only width 1 is guaranteed to be supported; others depend on the implementation. To query the range of supported widths, call glGet with argument GL_ALIASED_LINE_WIDTH_RANGE.)[GL ES 2.0]/(Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation. Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call glGet with arguments GL_ALIASED_LINE_WIDTH_RANGE, GL_SMOOTH_LINE_WIDTH_RANGE, and GL_SMOOTH_LINE_WIDTH_GRANULARITY.)[GL 2.1, GL 4]

Notes

The line width specified by glLineWidth is always returned when GL_LINE_WIDTH is queried. Clamping and rounding (for aliased and antialiased lines)[omitted in GL ES 2.0] have no effect on the specified value.

(Nonantialiased)[omitted in GL ES 2.0] Line width may be clamped to an implementation-dependent maximum. Call glGet with GL_ALIASED_LINE_WIDTH_RANGE to determine the maximum width.

(In OpenGL 1.2, the tokens GL_LINE_WIDTH_RANGE and GL_LINE_WIDTH_GRANULARITY were replaced by GL_ALIASED_LINE_WIDTH_RANGE, GL_SMOOTH_LINE_WIDTH_RANGE, and GL_SMOOTH_LINE_WIDTH_GRANULARITY. The old names are retained for backward compatibility, but should not be used in new code.)[omitted in GL ES 2.0]


errors:
    GL_INVALID_VALUE is generated if
        - width is less than or equal to 0.

associated gets:
    glGet with argument GL_LINE_WIDTH
    glGet with argument GL_ALIASED_LINE_WIDTH_RANGE
    glGet with argument GL_SMOOTH_LINE_WIDTH_RANGE [GL 2.1, GL 4]
    glGet with argument GL_SMOOTH_LINE_WIDTH_GRANULARITY [GL 2.1, GL 4]
    glIsEnabled with argument GL_LINE_SMOOTH [GL 2.1, GL 4]
























glLinkProgram — link a program object
    void glLinkProgram(GLuint program);

program:
    Specifies the handle of the program object to be linked.

glLinkProgram links the program object specified by program. (A shader object of type GL_VERTEX_SHADER attached to program is)[GL ES 2.0]/(If any shader objects of type GL_VERTEX_SHADER are attached to program, they will be)[GL 2.1] used to create an executable that will run on the programmable vertex processor. (A shader object of type GL_FRAGMENT_SHADER attached to program is)[GL ES 2.0]/(If any shader objects of type GL_FRAGMENT_SHADER are attached to program, they will be)[GL 2.1] used to create an executable that will run on the programmable fragment processor.

The status of the link operation will be stored as part of the program object's state. This value will be set to GL_TRUE if the program object was linked without errors and is ready for use, and GL_FALSE otherwise. It can be queried by calling glGetProgram[iv] with arguments program and GL_LINK_STATUS.

As a result of a successful link operation, all active user-defined uniform variables belonging to program will be initialized to 0, and each of the program object's active uniform variables will be assigned a location that can be queried by calling glGetUniformLocation. Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index will be bound to one at this time.

Linking of a program object can fail for a number of reasons as specified in the OpenGL [ES](GL ES 2.0 only) Shading Language Specification. The following lists some of the conditions that will cause a link error.

    A vertex shader and a fragment shader are not both present in the program object. [GL ES 2.0 only]

    The number of active attribute variables supported by the implementation has been exceeded.

    The storage limit for uniform variables has been exceeded.

    The number of active uniform variables supported by the implementation has been exceeded.

    The main function is missing for the vertex shader or the fragment shader.

    A varying variable actually used in the fragment shader is not declared in the same way (or is not declared at all) in the vertex shader.

    A reference to a function or variable name is unresolved.

    A shared global is declared with two different types or two different initial values.

    One or more of the attached shader objects has not been successfully compiled ((via glCompileShader) or loaded with a pre-compiled shader binary (via glShaderBinary).)[GL ES 2.0 only]

    Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed maximum of GL_MAX_VERTEX_ATTRIBS.

    Not enough contiguous vertex attribute slots could be found to bind attribute matrices.

    (The program object contains objects to form a fragment shader but does not contain objects to form a vertex shader.

    The program object contains objects to form a geometry shader but does not contain objects to form a vertex shader.

    The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is not specified in any compiled geometry shader object.

    The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is specified differently in multiple geometry shader objects.

    The number of active outputs in the fragment shader is greater than the value of GL_MAX_DRAW_BUFFERS.

    The program has an active output assigned to a location greater than or equal to the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS and has an active output assigned an index greater than or equal to one.

    More than one varying out variable is bound to the same number and index.

    The explicit binding assigments do not leave enough space for the linker to automatically assign a location for a varying out array, which requires multiple contiguous locations.

    The count specified by glTransformFeedbackVaryings is non-zero, but the program object has no vertex or geometry shader.

    Any variable name specified to glTransformFeedbackVaryings in the varyings array is not declared as an output in the vertex shader (or the geometry shader, if active).

    Any two entries in the varyings array given glTransformFeedbackVaryings specify the same varying variable.

    The total number of components to capture in any transform feedback varying variable is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS and the buffer mode is GL_SEPARATE_ATTRIBS.)[GL 4 only]

When a program object has been successfully linked, the program object can be made part of current state by calling glUseProgram. Whether or not the link operation was successful, the program object's information log will be overwritten. The information log can be retrieved by calling glGetProgramInfoLog.

glLinkProgram will also install the generated executables as part of the current rendering state if the link operation was successful and the specified program object is already currently in use as a result of a previous call to glUseProgram. If the program object currently in use is relinked unsuccessfully, its link status will be set to GL_FALSE , but the executables and associated state will remain part of the current state until a subsequent call to glUseProgram removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.

(If program contains shader objects of type GL_VERTEX_SHADER but does not contain shader objects of type GL_FRAGMENT_SHADER, the vertex shader will be linked against the implicit interface for fixed functionality fragment processing. Similarly, if program contains shader objects of type GL_FRAGMENT_SHADER but it does not contain shader objects of type GL_VERTEX_SHADER, the fragment shader will be linked against the implicit interface for fixed functionality vertex processing.)[GL 2.1]/(If program contains shader objects of type GL_VERTEX_SHADER, and optionally of type GL_GEOMETRY_SHADER, but does not contain shader objects of type GL_FRAGMENT_SHADER, the vertex shader executable will be installed on the programmable vertex processor, the geometry shader executable, if present, will be installed on the programmable geometry processor, but no executable will be installed on the fragment processor. The results of rasterizing primitives with such a program will be undefined.) [GL 4]

The program object's information log is updated and the program is generated at the time of the link operation. After the link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader objects, delete shader objects, and attach additional shader objects. None of these operations affects the information log or the program that is part of the program object.

Notes

If the link operation is unsuccessful, any information about a previous link operation on program is lost (i.e., a failed link does not restore the old state of program). Certain information can still be retrieved from program even after an unsuccessful link operation. See for instance glGetActiveAttrib and glGetActiveUniform.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
    GL_INVALID_OPERATION is generated if
        - program is the currently active program object and transform feedback mode is active. [GL 4 only]


associated gets:
    glGet with the argument GL_CURRENT_PROGRAM
    glGetActiveAttrib with argument program and the index of an active attribute variable
    glGetActiveUniform with argument program and the index of an active uniform variable
    glGetAttachedShaders with argument program
    glGetAttribLocation with argument program and an attribute variable name
    glGetProgram[iv] with arguments program and GL_LINK_STATUS
    glGetProgramInfoLog with argument program
    glGetUniform with argument program and a uniform variable location
    glGetUniformLocation with argument program and a uniform variable name
    glIsProgram
















glPixelStore[i] — set pixel storage modes
    void glPixelStorei(GLenum pname, GLint param);

pname:
    Specifies the symbolic name of the parameter to be set. One value affects the packing of pixel data into memory: GL_PACK_ALIGNMENT. The other affects the unpacking of pixel data from memory: GL_UNPACK_ALIGNMENT. Limitation as per GL ES 2.0

param:
    Specifies the value that pname is set to.

glPixelStore[i] sets pixel storage modes that affect the operation of subsequent glReadPixels as well as the unpacking of texture patterns (see glTexImage2D and glTexSubImage2D).

pname is a symbolic constant indicating the parameter to be set, and param is the new value. One storage parameter affects how pixel data is returned to client memory:

GL_PACK_ALIGNMENT
    Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).

The other storage parameter affects how pixel data is read from client memory:

GL_UNPACK_ALIGNMENT
    Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).

The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with glPixelStorei.

pname               Type        Initial Value       Valid Range
GL_PACK_ALIGNMENT   integer     4                   1, 2, 4, or 8
GL_UNPACK_ALIGNMENT integer     4                   1, 2, 4, or 8

Boolean parameters are set to false if param is 0 and true otherwise.

Notes:

(The pixel storage modes in effect when glDrawPixels, glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glBitmap, or glPolygonStipple is placed in a display list control the interpretation of memory data. Likewise, if the ARB_imaging extension is supported, the pixel storage modes in effect when glColorTable, glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D, of glSeparableFilter2D is placed in a display list control the interpretation of memory data. The pixel storage modes in effect when a display list is executed are not significant.

Pixel storage modes are client state and must be pushed and restored using glPushClientAttrib and glPopClientAttrib. )[GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - pname is not an accepted value.
    GL_INVALID_VALUE is generated if
        - alignment is specified as other than 1, 2, 4, or 8.

associated gets:
    glGet with argument GL_PACK_ALIGNMENT or GL_UNPACK_ALIGNMENT








glPolygonOffset — set the scale and units used to calculate depth values
    void glPolygonOffset(GLfloat factor, GLfloat units);

factor:
    Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.

units:
    Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.

When GL_POLYGON_OFFSET_FILL(, GL_POLYGON_OFFSET_LINE, or GL_POLYGON_OFFSET_POINT)[omitted in GL ES 2.0] is enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The value of the offset is factor*DZ + r*units , where DZ is a measurement of the change in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer.

glPolygonOffset is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.

Notes:

(glPolygonOffset has no effect on depth coordinates placed in the feedback buffer.

glPolygonOffset has no effect on selection.)[GL 2.1 only]

associated gets:
    glIsEnabled with argument GL_POLYGON_OFFSET_FILL. (, GL_POLYGON_OFFSET_LINE, or GL_POLYGON_OFFSET_POINT.)[omitted in GL ES 2.0]
    glGet with argument GL_POLYGON_OFFSET_FACTOR or GL_POLYGON_OFFSET_UNITS.








glReadPixels — read a block of pixels from the frame buffer
    void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data);

x, y:
    Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.

width, height:
    Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.

format:
    Specifies the format of the pixel data. The following symbolic values are accepted: GL_RGB, and GL_RGBA. Limitation as per GL ES 2.0 and GL 4

type:
    Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, or GL_UNSIGNED_SHORT_5_5_5_1. Limitation as per GL ES 2.0

data:
    Returns the pixel data.

glReadPixels returns pixel data from the frame buffer, starting with the pixel whose lower left corner is at location (x, y), into client memory starting at location data. (The GL_PACK_ALIGNMENT parameter, set with the glPixelStorei command, affects the processing of the pixel data before it is placed into client memory.)[GL ES 2.0]/(Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with (three commands: glPixelStore, glPixelTransfer, and glPixelMap)[GL 2.1]/(glPixelStore)[GL 4]. This reference page describes the effects on glReadPixels of most, but not all of the parameters specified by these three commands.

If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target (see glBindBuffer) while a block of pixels is requested, data is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.)[GL 2.1, GL 4]

(When the ARB_imaging extension is supported, the pixel data may be processed by additional operations including color table lookup, color matrix transformations, convolutions, histograms, and minimum and maximum pixel value computations.)[GL 2.1 only]

glReadPixels returns values from each pixel with lower left corner at (x + i, y + j) for 0 <= i < width and 0 <= j < height . This pixel is said to be the ith pixel in the jth row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.

format specifies the format for the returned pixel values; accepted values are:


GL_RGB
GL_RGBA
    (( Processing differs depending on whether color buffers store color indices or RGBA color components. If color indices are stored, they are read from the color buffer selected by glReadBuffer. Each index is converted to fixed point, shifted left or right depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET. Indices are then replaced by the red, green, blue, and alpha values obtained by indexing the tables GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A. Each table must be of size 2 n , but n may be different for different tables. Before an index is used to look up a value in a table of size 2 n , it must be masked against 2 n - 1 . )[omitted in GL ES 2.0]

    (If)[Omitted in GL ES 2.0] RGBA color components (are stored in the color buffers, they)[omitted in GL ES 2.0] are read from the color buffer (selected by glReadBuffer)[omitted in GL ES 2.0]. Each color component is converted to floating point such that zero intensity maps to 0.0 and full intensity maps to 1.0. (Each component is then multiplied by GL_c_SCALE and added to GL_c_BIAS, where c is RED, GREEN, BLUE, or ALPHA. Finally, if GL_MAP_COLOR is GL_TRUE, each component is clamped to the range 0 1 , scaled to the size of its corresponding table, and is then replaced by its mapping in the table GL_PIXEL_MAP_c_TO_c, where c is R, G, B, or A)[Omitted in GL ES 2.0]

    Unneeded data is then discarded. For example, GL_RGB discards only the alpha component. The final values are clamped to the range 0 1 .)[GL ES 2.0, GL 2.1]/(Color values are taken from the color buffer.)[GL 4]

(The shift, scale, bias, and lookup factors just described are all specified by glPixelTransfer. The lookup table contents themselves are specified by glPixelMap.)[GL 2.1 only]

Finally, the components are converted to the proper format, as specified by type. When type is GL_UNSIGNED_BYTE, each component is multiplied by 2^8 - 1 . When type is GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, or GL_UNSIGNED_SHORT_5_5_5_1, each component is multiplied by 2^N - 1 , where N is the number of bits in the bitfield. [This is per GL ES 2.0; GL 2.1 and GL 4 has (2^8 - 1)c for GL_UNSIGNED_BYTE and (2^16 - 1)c for GL_UNSIGNED_SHORT, and GL 4 (2^N - 1)c for the GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4 and GL_UNSIGNED_SHORT_5_5_5_1 types, with 2^N - 1 set at the index mask for the GL_STENCIL_INDEX, unavailable in GL ES 2.0]

Return values are placed in memory as follows. GL_RGB returns three values and GL_RGBA returns four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in data. Storage parameter GL_PACK_ALIGNMENT, set by glPixelStore[i], affects the way that data is written into memory. See glPixelStore[i] for a description.

Notes

(If the currently bound framebuffer is not the default framebuffer object, color components are read from the color image attached to the GL_COLOR_ATTACHMENT0 attachment point.

Only two format/type parameter pairs are accepted. GL_RGBA/GL_UNSIGNED_BYTE is always accepted, and the other acceptable pair can be discovered by querying GL_IMPLEMENTATION_COLOR_READ_FORMAT and GL_IMPLEMENTATION_COLOR_READ_TYPE.)[GL ES 2.0 only] [because not admissable for general glGet, this only leaves the default GL_RGBA + GL_UNSIGNED_BYTE as practicaly usable!]

Values for pixels that lie outside the window connected to the current GL context are undefined.

If an error is generated, no change is made to the contents of data.

errors:
    GL_INVALID_ENUM is generated if
        - format or type is not an accepted value.
    GL_INVALID_VALUE is generated if
        - either width or height is negative.
    GL_INVALID_OPERATION is generated if
        - type is GL_UNSIGNED_SHORT_5_6_5 and format is not GL_RGB.
        - type is GL_UNSIGNED_SHORT_4_4_4_4 or GL_UNSIGNED_SHORT_5_5_5_1 and format is not GL_RGBA.
        - format and type are neither GL_RGBA and GL_UNSIGNED_BYTE, respectively, nor the format/type pair returned by querying GL_IMPLEMENTATION_COLOR_READ_FORMAT and GL_IMPLEMENTATION_COLOR_READ_TYPE. [GL ES 2.0 only]
        (- a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer object's data store is currently mapped.
        - a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.
        - a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.)[GL 2.1, GL 4]
        - GL_READ_FRAMEBUFFER_BINDING is non-zero, the read framebuffer is complete, and the value of GL_SAMPLE_BUFFERS for the read framebuffer is greater than zero. [GL 4 only]
    GL_INVALID_FRAMEBUFFER_OPERATION is generated if
        - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). [GL ES 2.0 only]

associated gets:
    glGet with argument GL_IMPLEMENTATION_COLOR_READ_FORMAT or GL_IMPLEMENTATION_COLOR_READ_TYPE [GL ES 2.0 only]
    glGet with argument GL_PACK_ALIGNMENT  [GL ES 2.0 only]
    glGet with argument GL_INDEX_MODE [GL 2.1]
    glGet with argument GL_PIXEL_PACK_BUFFER_BINDING [GL 2.1]








glSampleCoverage — specify multisample coverage parameters
    void glSampleCoverage(GLclampf value, GLboolean invert); [GL ES 2.0, GL 2.1]
    void glSampleCoverage(GLfloat value, GLboolean invert); [GL 4]

value:
    Specify a single floating-point sample coverage value. The value is clamped to the range [0, 1] . The initial value is 1.0.

invert:
    Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE.

Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing effects. Multisampling transparently antialiases points, lines, and polygons ((bitmaps)[only GL 2.1], and images)[omitted in GL ES 2.0] if it is enabled.

value is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment color. This mask is bitwise-anded with the coverage mask generated from the multisampling computation. If the invert flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed.

If an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs with only a single sample computing a pixel's final RGB color.

Provided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated by combining several samples per pixel. Each sample contains color, depth, and stencil information, allowing those operations to be performed on each sample.

Notes

The type of the value parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

associated gets:
    glGet with argument GL_SAMPLE_COVERAGE_VALUE
    glGet with argument GL_SAMPLE_COVERAGE_INVERT
    glIsEnabled with argument GL_MULTISAMPLE [omitted in GL ES 2.0]
    glIsEnabled with argument GL_SAMPLE_ALPHA_TO_COVERAGE
    glIsEnabled with argument GL_SAMPLE_ALPHA_TO_ONE [omitted in GL ES 2.0]
    glIsEnabled with argument GL_SAMPLE_COVERAGE





glScissor — define the scissor box
    void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);

x, y:
    Specify the lower left corner of the scissor box. Initially (0, 0).

width, height:
    Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.

glScissor defines a rectangle, called the scissor box, in window coordinates. The first two arguments, x and y, specify the lower left corner of the box. width and height specify the width and height of the box.

To enable and disable the scissor test, call glEnable and glDisable with argument GL_SCISSOR_TEST. The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any pixels in the window.

When the scissor test is disabled, it is as though the scissor box includes the entire window.

errors:
    GL_INVALID_VALUE is generated if
        - either width or height is negative.

associated gets:
    glGet with argument GL_SCISSOR_BOX
    glIsEnabled with argument GL_SCISSOR_TEST












glShaderSource — replace the source code in a shader object
    void glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length); [GL ES 2.0]
    void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length); [GL 2.1, GL 4]

shader
    Specifies the handle of the shader object whose source code is to be replaced.

count
    Specifies the number of elements in the string and length arrays.

string
    Specifies an array of pointers to strings containing the source code to be loaded into the shader.

length
    Specifies an array of string lengths.

(For implementations that support a shader compiler,)[GL ES 2.0 only] glShaderSource sets the source code in shader to the source code in the array of strings specified by string. Any source code previously stored in the shader object is completely replaced. The number of strings in the array is specified by count. If length is NULL, each string is assumed to be null terminated. If length is a value other than NULL, it points to an array containing a string length for each of the corresponding elements of string. Each element in the length array may contain the length of the corresponding string (the null character is not counted as part of the string length) or a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed at this time; they are simply copied into the specified shader object.

Notes

(Shader compiler support is optional, and thus must be queried before use by calling glGet with argument GL_SHADER_COMPILER. glShaderSource, glCompileShader, glGetShaderPrecisionFormat, and glReleaseShaderCompiler will each generate GL_INVALID_OPERATION on implementations that do not support a shader compiler. Such implementations instead offer the glShaderBinary alternative for supplying a pre-compiled shader binary.)[GL ES 2.0 only]

OpenGL copies the shader source code strings when glShaderSource is called, so an application may free its copy of the source code strings immediately after the function returns.

errors:
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.
        - count is less than 0.
    GL_INVALID_OPERATION is generated if
        - a shader compiler is not supported. [GL ES 2.0 only]
        - shader is not a shader object.

associated gets:
    glGet with argument GL_SHADER_COMPILER [GL ES 2.0 only]
    glGetShader[iv] with arguments shader and GL_SHADER_SOURCE_LENGTH
    glGetShaderSource with argument shader
    glIsShader

















.

.

.











glStencilFunc — set front and back function and reference value for stencil testing
    void glStencilFunc(GLenum func, GLint ref, GLuint mask);

func:
    Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.

ref:
    Specifies the reference value for the stencil test. ref is clamped to the range [0, 2^n - 1] , where n is the number of bitplanes in the stencil buffer. The initial value is 0.

mask:
    Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.

Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call glEnable and glDisable with argument GL_STENCIL_TEST. To specify actions based on the outcome of the stencil test, call glStencilOp or glStencilOpSeparate.

There can be two separate sets of func, ref, and mask parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. glStencilFunc sets both front and back stencil state to the same values. Use glStencilFuncSeparate to set front and back stencil state to different values.

func is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. ref is an integer reference value that is used in the stencil comparison. It is clamped to the range [0, 2^n - 1] , where n is the number of bitplanes in the stencil buffer. mask is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.

If stencil represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by func. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see glStencilOp). All tests treat stencil values as unsigned integers in the range [0, 2^n - 1] , where n is the number of bitplanes in the stencil buffer.

The following values are accepted by func:

GL_NEVER
    Always fails.

GL_LESS
    Passes if ( ref & mask ) < ( stencil & mask ).

GL_LEQUAL
    Passes if ( ref & mask ) <= ( stencil & mask ).

GL_GREATER
    Passes if ( ref & mask ) > ( stencil & mask ).

GL_GEQUAL
    Passes if ( ref & mask ) >= ( stencil & mask ).

GL_EQUAL
    Passes if ( ref & mask ) = ( stencil & mask ).

GL_NOTEQUAL
    Passes if ( ref & mask ) != ( stencil & mask ).

GL_ALWAYS
    Always passes.

Notes

Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.

glStencilFunc is the same as calling glStencilFuncSeparate with face set to GL_FRONT_AND_BACK.

errors:
    GL_INVALID_ENUM is generated if
        - func is not one of the eight accepted values.

associated gets:
    glGet with argument GL_STENCIL_FUNC, GL_STENCIL_VALUE_MASK, GL_STENCIL_REF, GL_STENCIL_BACK_FUNC, GL_STENCIL_BACK_VALUE_MASK, GL_STENCIL_BACK_REF, or GL_STENCIL_BITS
    glIsEnabled with argument GL_STENCIL_TEST


































glStencilFuncSeparate — set front and/or back function and reference value for stencil testing
    void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);

face:
    Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.

func:
    Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.

ref:
    Specifies the reference value for the stencil test. ref is clamped to the range [0, 2^n - 1] , where n is the number of bitplanes in the stencil buffer. The initial value is 0.

mask:
    Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.

Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call glEnable and glDisable with argument GL_STENCIL_TEST. To specify actions based on the outcome of the stencil test, call glStencilOp or glStencilOpSeparate.

There can be two separate sets of func, ref, and mask parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. glStencilFunc sets both front and back stencil state to the same values, as if glStencilFuncSeparate were called with face set to GL_FRONT_AND_BACK.

func is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. ref is an integer reference value that is used in the stencil comparison. It is clamped to the range [0, 2^n - 1] , where n is the number of bitplanes in the stencil buffer. mask is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.

If stencil represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by func. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see glStencilOp). All tests treat stencil values as unsigned integers in the range [0, 2^n - 1] , where n is the number of bitplanes in the stencil buffer.

The following values are accepted by func:

GL_NEVER
    Always fails.

GL_LESS
    Passes if ( ref & mask ) < ( stencil & mask ).

GL_LEQUAL
    Passes if ( ref & mask ) <= ( stencil & mask ).

GL_GREATER
    Passes if ( ref & mask ) > ( stencil & mask ).

GL_GEQUAL
    Passes if ( ref & mask ) >= ( stencil & mask ).

GL_EQUAL
    Passes if ( ref & mask ) = ( stencil & mask ).

GL_NOTEQUAL
    Passes if ( ref & mask ) != ( stencil & mask ).

GL_ALWAYS
    Always passes.

Notes

Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.

errors:
    GL_INVALID_ENUM is generated if
        - face is not GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. [GL ES 2.0 only]
        - func is not one of the eight accepted values.

associated gets:
    glGet with argument GL_STENCIL_FUNC, GL_STENCIL_VALUE_MASK, GL_STENCIL_REF, GL_STENCIL_BACK_FUNC, GL_STENCIL_BACK_VALUE_MASK, GL_STENCIL_BACK_REF, or GL_STENCIL_BITS
    glIsEnabled with argument GL_STENCIL_TEST














glStencilMask — control the front and back writing of individual bits in the stencil planes
    void glStencilMask(GLuint mask);

mask:
    Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.

glStencilMask controls the writing of individual bits in the stencil planes. The least significant n bits of mask, where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.

There can be two separate mask writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. glStencilMask sets both front and back stencil writemasks to the same values. Use glStencilMaskSeparate to set front and back stencil writemasks to different values.

Notes

glStencilMask is the same as calling glStencilMaskSeparate with face set to GL_FRONT_AND_BACK.

associated gets:
    glGet with argument GL_STENCIL_WRITEMASK, GL_STENCIL_BACK_WRITEMASK, or GL_STENCIL_BITS
















glStencilMaskSeparate — control the front and/or back writing of individual bits in the stencil planes
    void glStencilMaskSeparate(GLenum face, GLuint mask);

face:
    Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.

mask:
    Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.

glStencilMaskSeparate controls the writing of individual bits in the stencil planes. The least significant n bits of mask, where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.

There can be two separate mask writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. glStencilMask sets both front and back stencil writemasks to the same values, as if glStencilMaskSeparate were called with face set to GL_FRONT_AND_BACK.

errors:
    GL_INVALID_ENUM is generated if
        - face is not GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. [GL ES 2.0, GL 4]

associated gets:
    glGet with argument GL_STENCIL_WRITEMASK, GL_STENCIL_BACK_WRITEMASK, or GL_STENCIL_BITS












glStencilOp — set front and back stencil test actions
    void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);

sfail:
    Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.

dpfail:
    Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.

dppass:
    Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.

Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call glEnable and glDisable with argument GL_STENCIL_TEST; to control it, call glStencilFunc or glStencilFuncSeparate.

There can be two separate sets of sfail, dpfail, and dppass parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. glStencilOp sets both front and back stencil state to the same values. Use glStencilOpSeparate to set front and back stencil state to different values.

glStencilOp takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and sfail specifies what happens to the stencil buffer contents. The following eight actions are possible.

GL_KEEP
    Keeps the current value.

GL_ZERO
    Sets the stencil buffer value to 0.

GL_REPLACE
    Sets the stencil buffer value to ref, as specified by glStencilFunc.

GL_INCR
    Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.

GL_INCR_WRAP
    Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.

GL_DECR
    Decrements the current stencil buffer value. Clamps to 0.

GL_DECR_WRAP
    Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.

GL_INVERT
    Bitwise inverts the current stencil buffer value.

Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2^n - 1 , where n is the value returned by querying GL_STENCIL_BITS.

The other two arguments to glStencilOp specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed (dppass) or fail (dpfail) (see glDepthFunc). The actions are specified using the same eight symbolic constants as sfail. Note that dpfail is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, sfail and dppass specify stencil action when the stencil test fails and passes, respectively.

Notes

Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to glStencilOp.

glStencilOp is the same as calling glStencilOpSeparate with face set to GL_FRONT_AND_BACK.

errors:
    GL_INVALID_ENUM is generated if
        - sfail, dpfail, or dppass is any value other than the eight defined (symbolic)[GL ES 2.0 only] constant values.

associated gets:
    glGet with argument GL_STENCIL_FAIL, GL_STENCIL_PASS_DEPTH_PASS, GL_STENCIL_PASS_DEPTH_FAIL, GL_STENCIL_BACK_FAIL, GL_STENCIL_BACK_PASS_DEPTH_PASS, GL_STENCIL_BACK_PASS_DEPTH_FAIL, or GL_STENCIL_BITS
    glIsEnabled with argument GL_STENCIL_TEST




















glStencilOpSeparate — set front and/or back stencil test actions
    void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);

face:
    Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.

sfail:
    Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.

dpfail:
    Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.

dppass:
    Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.

Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call glEnable and glDisable with argument GL_STENCIL_TEST; to control it, call glStencilFunc or glStencilFuncSeparate.

There can be two separate sets of sfail, dpfail, and dppass parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. glStencilOp sets both front and back stencil state to the same values, as if glStencilOpSeparate were called with face set to GL_FRONT_AND_BACK.

glStencilOpSeparate takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and sfail specifies what happens to the stencil buffer contents. The following eight actions are possible.

GL_KEEP

    Keeps the current value.
GL_ZERO

    Sets the stencil buffer value to 0.
GL_REPLACE

    Sets the stencil buffer value to ref, as specified by glStencilFunc.
GL_INCR

    Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
GL_INCR_WRAP

    Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.
GL_DECR

    Decrements the current stencil buffer value. Clamps to 0.
GL_DECR_WRAP

    Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.
GL_INVERT

    Bitwise inverts the current stencil buffer value.

Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2^n - 1 , where n is the value returned by querying GL_STENCIL_BITS.

The other two arguments to glStencilOpSeparate specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed (dppass) or fail (dpfail) (see glDepthFunc). The actions are specified using the same eight symbolic constants as sfail. Note that dpfail is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, sfail and dppass specify stencil action when the stencil test fails and passes, respectively.

Notes

Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.

errors:
    GL_INVALID_ENUM is generated if
        - face is any value other than GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
        - sfail, dpfail, or dppass is any value other than the eight defined (symbolic)[GL ES 2.0 only] constant values.

associated gets:
    glGet with argument GL_STENCIL_FAIL, GL_STENCIL_PASS_DEPTH_PASS, GL_STENCIL_PASS_DEPTH_FAIL, GL_STENCIL_BACK_FAIL, GL_STENCIL_BACK_PASS_DEPTH_PASS, GL_STENCIL_BACK_PASS_DEPTH_FAIL, or GL_STENCIL_BITS
    glIsEnabled with argument GL_STENCIL_TEST




























glTexImage2D — specify a two-dimensional texture image
    void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
        GLint border, GLenum format, GLenum type, const void * data);

target:
    Specifies the target texture (of the active texture unit)[GL ES 2.0 only]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. Limitation as per GL ES 2.0

level:
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

internalformat:
    Specifies the (internal format of)[GL ES 2.0]/(number of color components in)[GL 2.1, GL 4] the texture. Must be one of the following symbolic constants: GL_RGB, GL_RGBA. Limitation as  per GL ES 2.0 and GL 4

width:
    Specifies the width of the texture image (including the border if any)[GL 2.1 only]. (If the GL version does not support non-power-of-two sizes, this value must be 2 n + 2 ⁡ border for some integer n.)[GL 2.1 only] All implementations support (2D)[GL ES 2.0 only] texture images that are at least 64 texels wide (and cube-mapped texture images that are at least 16 texels wide)[GL ES 2.0 only].

height:
    Specifies the height of the texture image(including the border if any)[GL 2.1 only]. (If the GL version does not support non-power-of-two sizes, this value must be 2 m + 2 ⁡ border for some integer m.)[GL 2.1 only] All implementations support (2D)[GL ES 2.0 only] texture images that are at least 64 texels high (and cube-mapped texture images that are at least 16 texels high.)[GL ES 2.0 only]

border:
    Specifies the width of the border. Must be 0. Limitation as per GL ES 2.0 and GL 4

format:
    Specifies the format of the (texel)[GL ES 2.0]/(pixel)[GL 2.1] data. Must match internalformat. The following symbolic values are accepted: GL_RGB, GL_RGBA. Limitation as per GL ES 2.0

type:
    Specifies the data type of the (texel)[GL ES 2.0]/(pixel)[GL 2.1] data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, and GL_UNSIGNED_SHORT_5_5_5_1. Limitation as per GL ES 2.0

data:
    Specifies a pointer to the image data in memory.

Texturing (maps a portion of a specified texture image onto each graphical primitive for which texturing is (active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0]/(enabled. To enable and disable two-dimensional texturing, call glEnable and glDisable with argument GL_TEXTURE_2D. To enable and disable texturing using cube-mapped texture, call glEnable and glDisable with argument GL_TEXTURE_CUBE_MAP.)[GL 2.1])[GL ES 2.0, GL 2.1]/(allows elements of an image array to be read by shaders.)[GL 4]

To define texture images, call glTexImage2D. The arguments describe the parameters of the texture image, such as height, width, (width of the border,)[GL 2.1, GL 4] level-of-detail number (see glTexParameter), and (format)[GL ES 2.0]/(number of color components provided)[GL 2.1, GL 4]. The last three arguments describe how the image is represented in memory.(they are identical to the pixel formats used for glDrawPixels.)[GL 2.1 only]

Data is read from data as a sequence of unsigned bytes or shorts, depending on type. (When type is GL_UNSIGNED_BYTE, each of the bytes is interpreted as one color component. When type is one of GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, or GL_UNSIGNED_SHORT_5_5_5_1, each unsigned short value is interpreted as containing all the components for a single texel, with the color components arranged according to format. Color components are treated as groups of one, two, three, or four values, again based on format. Groups of components are referred to as texels.

width × height texels are read from memory, starting at location data. By default, these texels are taken from adjacent memory locations, except that after all width texels are read, the read pointer is advanced to the next four-byte boundary. The four-byte row alignment is specified by glPixelStorei with argument GL_UNPACK_ALIGNMENT, and it can be set to one, two, four, or eight bytes.) [GL ES 2.0]/(These values are grouped into sets of one, two, three, or four values, depending on format, to form elements. (Each data byte is treated as eight 1-bit elements, with bit ordering determined by GL_UNPACK_LSB_FIRST (see glPixelStore).

If target is GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE or one of the GL_TEXTURE_CUBE_MAP targets, data is read from data as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on type. These values are grouped into sets of one, two, three, or four values, depending on format, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by GL_UNPACK_LSB_FIRST (see glPixelStore).

If target is GL_TEXTURE_1D_ARRAY, data is interpreted as an array of one-dimensional images.)[GL 4 only]

If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image is specified, data is treated as a byte offset into the buffer object's data store.)[GL 2.1, GL 4]

The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.

format determines the composition of each element in data. It can assume one of these symbolic values:

GL_RGB
    Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is then (multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and)[GL 2.1 only] clamped to the range [0,1].((see glPixelTransfer).)[GL 2.1 only]

GL_RGBA
    Each element contains all four components. (The GL converts it to floating point, then)[GL ES 2.0 only] each component is (multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and)[GL 2.1 only] clamped to the range [0,1]. ((see glPixelTransfer).)[GL 2.1 only]


(Color components are converted to floating point based on the type. When type is GL_UNSIGNED_BYTE, each component is divided by 2 8 - 1 . When type is GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, or GL_UNSIGNED_SHORT_5_5_5_1, each component is divided by 2 N - 1 , where N is the number of bits in the bitfield.)[GL ES 2.0 only]

((Refer to the glDrawPixels reference page for a description of the acceptable values for the type parameter.)[GL 2.1 only]

If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with internalFormat. The GL will choose an internal representation that closely approximates that requested by internalFormat, but it may not match exactly. (The representations specified by (GL_LUMINANCE, GL_LUMINANCE_ALPHA,)[GL 2.1]/(GL_RED, GL_RG,)[GL 4] GL_RGB, and GL_RGBA must match exactly. (The numeric values 1, 2, 3, and 4 may also be used to specify the above representations.)[GL 2.1 only])) [GL 2.1, GL 4]

(internalformat may be one of the base internal formats shown in Table 1, below:
[only the two relevant entries:]
Base Internal Format 	  RGBA, Depth and Stencil Values 	    Internal Components
[...]
GL_RGB 	                  Red, Green, Blue 	                    R, G, B
GL_RGBA 	              Red, Green, Blue, Alpha 	            R, G, B, A

internalformat may also be one of the sized internal formats shown in Table 2, below:
[...]
Finally, internalformat may also be one of the generic or compressed texture formats shown in Table 3 below:
[...]
)[GL 4 only]

(A one-component texture image uses only the red component of the RGBA color extracted from data. A two-component image uses the R and (A)[GL 2.1]/(G)[GL 4] values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.

(Depth textures can be treated as LUMINANCE, INTENSITY or ALPHA textures during texture filtering and application.)[GL 2.1 only] Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See glTexParameter for details on texture comparison. )[GL 2.1, GL 4]


Notes

( The glPixelStore mode affects texture images.)[GL 4 only]

(internalformat must match format. No conversion between formats is supported during texture image processing. type may be used as a hint to specify how much precision is desired, but a GL implementation may choose to store the texture array at any internal resolution it chooses.)[GL ES 2.0 only]

data may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width width and height height. You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive.

glTexImage2D specifies a two-dimensional (or cube-map texture)[GL ES 2.0 only] for the current texture unit, specified with glActiveTexture.

(Texturing has no effect in color index mode.

If the ARB_imaging extension is supported, RGBA elements may also be processed by the imaging pipeline. The following stages may be applied to an RGBA color before color component clamping to the range 0 1 :

1. Color component replacement by the color table specified for
    GL_COLOR_TABLE, if enabled. See glColorTable.
2. Two-dimensional Convolution filtering, if enabled.
    See glConvolutionFilter1D.
    If a convolution filter changes the width of the texture (by processing with a GL_CONVOLUTION_BORDER_MODE of GL_REDUCE, for example), and the GL does not support non-power-of-two textures, the width must 2 n + 2 ⁡ border, for some integer n, and height must be 2 m + 2 ⁡ border , for some integer m, after filtering.
3. RGBA components may be multiplied by GL_POST_CONVOLUTION_c_SCALE,
    and added to GL_POST_CONVOLUTION_c_BIAS, if enabled. See glPixelTransfer.
4. Color component replacement by the color table specified for
    GL_POST_CONVOLUTION_COLOR_TABLE, if enabled. See glColorTable.
5. Transformation by the color matrix.
    See glMatrixMode.
6. RGBA components may be multiplied by GL_POST_COLOR_MATRIX_c_SCALE,
    and added to GL_POST_COLOR_MATRIX_c_BIAS, if enabled. See glPixelTransfer.
7. Color component replacement by the color table specified for
    GL_POST_COLOR_MATRIX_COLOR_TABLE, if enabled. See glColorTable.

The texture image can be represented by the same data formats as the pixels in a glDrawPixels command, except that GL_STENCIL_INDEX cannot be used. glPixelStore and glPixelTransfer modes affect texture images in exactly the way they affect glDrawPixels.

Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the GL_ARB_texture_non_power_of_two extension.)[GL 2.1 only]


errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        - format or type is not an accepted value. [GL ES 2.0 only]
        - target is one of the six cube map 2D image targets and the width and height parameters are not equal.[GL 2.1, GL 4]
        - type is not a type constant. [GL 2.1, GL 4]
    GL_INVALID_VALUE is generated if
        - target is one of the six cube map 2D image targets and the width and height parameters are not equal. [GL ES 2.0 only]
        - level is less than 0.
        - internalformat is not (an accepted format.)[GL ES 2.0]/(1, 2, 3, 4, or one of the accepted resolution and format symbolic constants.)[GL 2.1, GL 4]
        - width or height is less than 0 or greater than (GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.)[GL ES 2.0]/(2 + GL_MAX_TEXTURE_SIZE)[GL 2.1]/(GL_MAX_TEXTURE_SIZE)[GL 4]
        - border is not 0.
        - non-power-of-two textures are not supported and the width or height cannot be represented as 2 k + 2 ⁡ border for some integer value of k. [GL 2.1 only]
    GL_INVALID_VALUE may be generated if
        - level is greater than log_2(max) , where max is the returned value of (GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.)[GL ES 2.0]/(GL_MAX_TEXTURE_SIZE)[GL 2.1, GL 4]
    GL_INVALID_OPERATION is generated if
        - format does not match internalformat. [GL ES 2.0 only]
        - type is GL_UNSIGNED_SHORT_5_6_5 and format is not GL_RGB.
        - type is GL_UNSIGNED_SHORT_4_4_4_4 or GL_UNSIGNED_SHORT_5_5_5_1 and format is not GL_RGBA.
        (- a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.)[GL 2.1, GL 4]

associated gets:
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0]
    glGetTexImage [GL 2.1, GL 4]
    glIsEnabled with argument GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP [GL 2.1 only]
    glGet with argument GL_PIXEL_UNPACK_BUFFER_BINDING [GL 2.1, GL 4]



























glTexParameter — set texture parameters
    void glTexParameterf(GLenum target, GLenum pname, GLfloat param);
    void glTexParameteri(GLenum target, GLenum pname, GLint param);
    void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params);
    void glTexParameteriv(GLenum target, GLenum pname, const GLint * params);

target:
    Specifies the target texture (of the active texture unit)[GL ES 2.0 only], which must be either GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP; but GL_TEXTURE_CUBE_MAP _only_ for glTexParameterf/glTexParameteri, not glTexParameterfv/glTexParameteriv [that Limitation only present in GL 2.1]. Limitation as per GL ES 2.0 and GL 2.1

pname:
    Specifies the symbolic name of a (single-valued)[only written under glTexParameter[f,i] not [fv,iv]] texture parameter. pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_WRAP_S, or GL_TEXTURE_WRAP_T. Limitation as per GL ES 2.0

param:
    Specifies the value of pname.

params
    Specifies a pointer to an array where the value (or values)[GL 2.1, GL 4] of pname are stored.

(Texture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap. The image is created in texture space, with an (s, t) coordinate system. A texture is a two-dimensional (or cube-mapped)[GL ES 2.0 only] image and a set of parameters that determine how samples are derived from the image.)[omitted in GL 4]

glTexParameter assigns the value or values in params to the texture parameter specified as pname. target defines the target texture of the active texture unit, either GL_TEXTURE_2D or (GL_TEXTURE_CUBE_MAP)[GL ES 2.0 only; GL 2.1 has GL_TEXTURE_3D instead]. The following symbols are accepted in pname:

GL_TEXTURE_MIN_FILTER
    The texture minifying function is used whenever the (pixel being textured maps to an area greater than one texture element.)[GL ES 2.0, GL 2.1]/(level-of-detail function used when sampling from the texture determines that the texture should be minified.)[GL 4] There are six defined minifying functions. Two of them use (the nearest one or nearest four)[GL ES 2.0, GL 2.1]/(either the nearest texture elements or a weighted average of multiple)[GL 4] texture elements to compute the texture value. The other four use mipmaps.

    A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. (If the texture has dimensions w × h , there are floor ⁡ log 2 ⁡ max ⁡ w h + 1 mipmap levels. The first mipmap level is the original texture, with dimensions w × h . Each subsequent mipmap level has dimensions max ⁡ 1 floor ⁡ w 2 i × max ⁡ 1 floor ⁡ h 2 i , where i is the mipmap level, until the final mipmap is reached, which has dimension 1 × 1 .

    To define the mipmap levels, call glTexImage2D, glCompressedTexImage2D, or glCopyTexImage2D with the level argument indicating the order of the mipmaps. Level 0 is the original texture; level floor ⁡ log 2 ⁡ max ⁡ w h is the final 1 × 1 mipmap.)[GL ES 2.0]/(If the texture has dimensions 2^n × 2^m , there are max(⁡n, m) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2^ n × 2^ m . Each subsequent mipmap has dimensions 2^(k-1) × 2 ^(l-1) , where 2^k × 2^l are the dimensions of the previous mipmap, until either k = 0 or l = 0 . At that point, subsequent mipmaps have dimension 1 × 2^(l - 1) or 2^(k - 1) × 1 until the final mipmap, which has dimension 1 × 1 . To define the mipmaps, call glTexImage1D, glTexImage2D, glTexImage3D, glCopyTexImage1D, or glCopyTexImage2D with the level argument indicating the order of the mipmaps. Level 0 is the original texture; level max(n,m) is the final 1 × 1 mipmap.)[GL 2.1, GL 4]

    params supplies a function for minifying the texture as one of the following:

    GL_NEAREST
        Returns the value of the texture element that is nearest (in Manhattan distance) to the (center of the pixel being textured)[GL ES 2.0, GL 2.1]/(specified texture coordinates)[GL 4].

    GL_LINEAR
        Returns the weighted average of the four texture elements that are closest to the (center of the pixel being textured)[GL ES 2.0, GL 2.1]/(specified texture coordinates)[GL 4]. (These can include (border texture elements)[GL 2.1]/(items wrapped or repeated from other parts of a texture)[GL 4], depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T, and on the exact mapping. )[GL 2.1,m GL 4]

    GL_NEAREST_MIPMAP_NEAREST
        Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element (nearest to the center of the pixel)[GL ES 2.0, GL 2.1]/(closest to the specified texture coordinates)[GL 4]) to produce a texture value.

    GL_LINEAR_MIPMAP_NEAREST
        Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the (center of the pixel)[GL ES 2.0, GL 2.1]/(specified texture coordinates)[GL 4]) to produce a texture value.

    GL_NEAREST_MIPMAP_LINEAR
        Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element (nearest to the center of the pixel)[GL ES 2.0, GL 2.1]/(closest to the specified texture coordinates)[GL 4]) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.

    GL_LINEAR_MIPMAP_LINEAR
        Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the (four)[omitted in GL 4] texture elements that are closest to the (center of the pixel)[GL ES 2.0, GL 2.1]/(specified texture coordinates)[GL 4]) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.

    As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the GL_NEAREST and GL_LINEAR minification functions can be faster than the other four, they sample only one or (four)[GL ES 2.0, GL 2.1]/(multiple)[GL 4] texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of GL_TEXTURE_MIN_FILTER is GL_NEAREST_MIPMAP_LINEAR.

GL_TEXTURE_MAG_FILTER
    The texture magnification function is used (when the pixel being textured maps to an area less than or equal to one texture element.)[GL ES 2.0, GL 2.1]/(whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified)[GL 4]
    It sets the texture magnification function to either GL_NEAREST or GL_LINEAR (see below). GL_NEAREST is generally faster than GL_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of GL_TEXTURE_MAG_FILTER is GL_LINEAR.

    GL_NEAREST
        Returns the value of the texture element that is nearest (in Manhattan distance) to the (center of the pixel being textured.)[GL ES 2.0, GL 2.1]/(specified texture coordinates)[GL 4]
    GL_LINEAR
        Returns the weighted average of the (four)[omitted in GL 4] texture elements that are closest to the (center of the pixel being textured.)[GL ES 2.0, GL 2.1]/(specified texture coordinates)[GL 4]. (These can include (border texture elements)[GL 2.1]/(items wrapped or repeated from other parts of a texture)[GL 4], depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T, and on the exact mapping. )[GL 2.1, GL 4]

GL_TEXTURE_WRAP_S
    Sets the wrap parameter for texture coordinate s to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. Limitation as per GL ES 2.0. GL_CLAMP_TO_EDGE causes s coordinates to be clamped to the range [1/2N, 1 - 1/2N] , where N is the size of the texture in the direction of clamping. GL_REPEAT causes the integer part of the s coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. GL_MIRRORED_REPEAT causes the s coordinate to be set to the fractional part of the texture coordinate if the integer part of s is even; if the integer part of s is odd, then the s texture coordinate is set to 1 - frac(s) , where frac(s) represents the fractional part of s. Initially, GL_TEXTURE_WRAP_S is set to GL_REPEAT.

GL_TEXTURE_WRAP_T
    Sets the wrap parameter for texture coordinate t to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. Limitation as per GL ES 2.0 See the discussion under GL_TEXTURE_WRAP_S. Initially, GL_TEXTURE_WRAP_T is set to GL_REPEAT.

Notes

Suppose that a (texture is accessed from a fragment shader or vertex shader)[GL ES 2.0]/(program has enabled texturing (by calling glEnable with argument GL_TEXTURE_1D, GL_TEXTURE_2D, or GL_TEXTURE_3D))[GL 2.1]/(program attempts to sample from a texture)[GL 4] and has set GL_TEXTURE_MIN_FILTER to one of the functions that requires mipmaps. If either the dimensions of the texture images currently defined (with previous calls to glTexImage2D, (glCompressedTexImage2D)[GL ES 2.0 only], or glCopyTexImage2D) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images (were defined with different formats or types, then the texture image unit will return (R, G, B, A) = (0, 0, 0, 1).)[GL ES 2.0]/(have differing numbers of texture components, (then it is as if texture mapping were disabled.)[GL 2.1]/(the texture is considered incomplete.)[GL 4])[GL 2.1, GL 4]

(Similarly, if the width or height of a texture image are not powers of two and either the GL_TEXTURE_MIN_FILTER is set to one of the functions that requires mipmaps or the GL_TEXTURE_WRAP_S or GL_TEXTURE_WRAP_T is not set to GL_CLAMP_TO_EDGE, then the texture image unit will return (R, G, B, A) = (0, 0, 0, 1).)[GL ES 2.0]/(Linear filtering accesses the four nearest texture elements only in 2D textures. In 1D textures, linear filtering accesses the two nearest texture elements. (In 3D textures, linear filtering accesses the eight nearest texture elements.)[GL 4 only])[GL 2.1, GL 4]

glTexParameter specifies the texture parameters for the (texture bound to the)[GL ES 2.0 only] active texture unit, specified by calling glActiveTexture.

errors:
    GL_INVALID_ENUM is generated if
        - target or pname is not one of the accepted defined values.
        - params should have a defined symbolic constant value (based on the value of pname) and does not.

associated gets:
    glGetTexParameter
    glGetTextureParameter [GL 4]
    glGetTexLevelParameter [GL 4]
    glGetTextureLevelParameter [GL 4]








glTexSubImage2D — specify a two-dimensional texture subimage
    void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
        GLenum format, GLenum type, const void * data);

target:
    Specifies the target (texture (of the active texture unit)[GL ES 2.0 only])[GL ES 2.0, GL 2.1]/(to which the texture is bound)[GL 4]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.

level:
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

xoffset:
    Specifies a texel offset in the x direction within the texture array.

yoffset:
    Specifies a texel offset in the y direction within the texture array.

width:
    Specifies the width of the texture subimage.

height:
    Specifies the height of the texture subimage.

format:
    Specifies the format of the pixel data. The following symbolic values are accepted: GL_RGB and GL_RGBA. Limitation as per GL ES 2.0 and GL 4

type:
    Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, and GL_UNSIGNED_SHORT_5_5_5_1.

data:
    Specifies a pointer to the image data in memory.

Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is (active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0]/(enabled. (To enable and disable two-dimensional texturing, call glEnable and glDisable with argument GL_TEXTURE_2D.)[GL 2.1 only])[GL 2.1, GL 4]

glTexSubImage2D redefines a contiguous subregion of an existing two-dimensional texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset and xoffset + width - 1 , inclusive, and y indices yoffset and yoffset + height - 1 , inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.

(If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image is specified, data is treated as a byte offset into the buffer object's data store.)[GL 2.1, GL 4]

Notes

(Storage parameter GL_UNPACK_ALIGNMENT, set by glPixelStorei, affects the way that data is read out of client memory. See glPixelStorei for a description.)[GL ES 2.0]/(Texturing has no effect in color index mode.

glPixelStore and glPixelTransfer modes affect texture images in exactly the way they affect glDrawPixels.

When the ARB_imaging extension is supported, the RGBA components specified in data may be processed by the imaging pipeline. See glTexImage1D for specific details. )[GL 2.1]/(glPixelStore modes affect texture images.)[GL 4]

glTexSubImage2D specifies a two-dimensional (or cube-map)[GL ES 2.0 only] subtexture for the current texture unit, specified with glActiveTexture.

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        - format or type is not an accepted value.
    GL_INVALID_VALUE is generated if
        - level is less than 0.
        - xoffset < 0 , xoffset + width > w , yoffset < 0 , or yoffset + height > h , where w is the width and h is the height of the texture image being modified. [GL ES 2.0 only]
        - xoffset < - b , xoffset + width > w - b , yoffset < - b , or yoffset + height > h - b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the border width of the texture image being modified. Note that w and h include twice the border width. [GL 2.1, GL 4]
        - width or height is less than 0.
    GL_INVALID_VALUE may be generated if
        - level is greater than log_2(max), where max is the returned value of GL_MAX_TEXTURE_SIZE.
    GL_INVALID_OPERATION is generated if
        - the texture array has not been defined by a previous glTexImage2D (or glCopyTexImage2D)[GL ES 2.0 only] operation (whose internalformat matches the format of glTexSubImage2D)[GL ES 2.0 only].
        - type is GL_UNSIGNED_SHORT_5_6_5 and format is not GL_RGB.
        - type is GL_UNSIGNED_SHORT_4_4_4_4 or GL_UNSIGNED_SHORT_5_5_5_1 and format is not GL_RGBA.
        (- a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.)[GL 2.1, GL 4]

associated gets:
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0]
    glGetTexImage [GL 2.1, GL 4]
    glIsEnabled with argument GL_TEXTURE_2D [GL 2.1 only]
    glGet with argument GL_PIXEL_UNPACK_BUFFER_BINDING [GL 2.1, GL 4]









