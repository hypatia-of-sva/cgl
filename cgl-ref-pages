Common OpenGL Subset Documentation

Documentation of the common OpenGL subset. This includes the intersection of the OpenGL 2.1, OpenGL ES 2.0 and OpenGL 4 Reference Pages by Khronos, and describes therefore a commonly usable GL API.





glActiveTexture — select active texture unit
    void glActiveTexture(GLenum texture);

texture:
    Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.

glActiveTexture selects which texture unit subsequent texture state calls will affect. The number of texture units an implementation supports is implementation dependent, but must be at least 2 as per GL 2.1.

errors:
    GL_INVALID_ENUM is generated if
        - texture is not one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS-1).

associated gets:
    glGet with argument GL_ACTIVE_TEXTURE or GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS





glAttachShader — attach a shader object to a program object
    void glAttachShader(GLuint program, GLuint shader);

program:
    Specifies the program object to which a shader object will be attached.
shader:
    Specifies the shader object that is to be attached.

In order to create an executable/a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. glAttachShader attaches the shader object specified by shader to the program object specified by program. This indicates that shader will be included in link operations that will be performed on program.

All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. Multiple shader objects of the same type may not be attached to a single program object as per GL ES 2.9. However, a single shader object may be attached to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until glDetachShader is called to detach it from all program objects to which it is attached.

errors:
    GL_INVALID_VALUE is generated if
        - either program or shader is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - shader is not a shader object.
        - shader is already attached to program, or
        - (in ES 2.0 only) another shader object of the same type as shader is already attached to program.

associated gets:
    glGetAttachedShaders with the handle of a valid program object
    glIsProgram
    glIsShader








glBindAttribLocation — associate a generic vertex attribute index with a named attribute variable
    void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);

program:
    Specifies the handle of the program object in which the association is to be made.
index:
    Specifies the index of the generic vertex attribute to be bound.
name:
    Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.

glBindAttribLocation is used to associate a user-defined attribute variable in the program object specified by program with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in name. The generic vertex attribute index to be bound to this variable is specified by index. When program is made part of current state, values provided via the generic vertex attribute index will modify the value of the user-defined attribute variable specified by name.

If name refers to a matrix attribute variable, index refers to the first column of the matrix. Other matrix columns are then automatically bound to locations index+1 for a matrix of type mat2; index+1 and index+2 for a matrix of type mat3; and index+1, index+2, and index+3 for a matrix of type mat4.

This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from 0 to GL_MAX_VERTEX_ATTRIBS -1. The values sent to each generic attribute index are part of current state, (just like standard vertex attributes such as color, normal, and vertex position)[omitted in GL4]. If a different program object is made current by calling glUseProgram, the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to index.

Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling glBindAttribLocation. Attribute bindings do not go into effect until glLinkProgram is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs.

(Applications are not allowed to bind any of the standard OpenGL vertex attributes using this command, as they are bound automatically when needed.)[omitted in GL4] Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.


Notes

glBindAttribLocation can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.

If name was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index.

Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called aliasing, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing. (Because there is no way to bind standard attributes, it is not possible to alias generic attributes with conventional ones (except for generic attribute 0).)[omitted in GL4]

Active attributes that are not explicitly bound will be bound by the linker when glLinkProgram is called. The locations assigned can be queried by calling glGetAttribLocation.

OpenGL copies the name string when glBindAttribLocation is called, so an application may free its copy of the name string immediately after the function returns.

errors:
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - name starts with the reserved prefix "gl_".
        - program is not a program object.

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS
    glGetActiveAttrib with argument program
    glGetAttribLocation with arguments program and name
    glIsProgram











glBindBuffer — bind a named buffer object
    void glBindBuffer(GLenum target, GLuint buffer);

target:
    Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER [purpose: Vertex attributes, according to GL4] or GL_ELEMENT_ARRAY_BUFFER [purpose: Vertex array indices, according to GL4]. Limitation as per GL ES 2.0.
buffer:
    Specifies the name of a buffer object.

glBindBuffer lets you create or use a named buffer object. Calling glBindBuffer with target set to GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER and buffer set to the name of the new buffer object binds the buffer object name to the target. (If no buffer object with name buffer exists, one is created with that name.)[GL4 only] When a buffer object is bound to a target, the previous binding for that target is automatically broken.

Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target ((if supported for that target))[GL 4 only]. Buffer object names and the corresponding buffer object contents are local to the shared (object space)[as per ES 2.0 and GL4]/(display-list space (see glXCreateContext))[as per GL 2.1] of the current GL rendering context(; two rendering contexts share buffer object names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in ES 2.0]

(You may use glGenBuffers to generate a set of new buffer object names.)[GL ES 2.0, GL 2.1]/(glGenBuffers must be used to generate a set of unused buffer object names.)[GL 4]

The state of a buffer object immediately after it is first bound is a[n] (unmapped)[omitted in GL ES 2.0] zero-sized memory buffer with (GL_READ_WRITE access and)[omitted in GL ES 2.0] GL_STATIC_DRAW usage.

While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an GL_INVALID_OPERATION error.

When vertex array pointer state is changed (by a call to glVertexAttribPointer)[ES 2.0]/(for example by a call to glNormalPointer)[GL 2.1], the current buffer object binding (GL_ARRAY_BUFFER_BINDING) is copied into the corresponding client state for (the vertex attrib array being changed, one of the indexed GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDINGs)[ES 2.0]/(vertex array type being changed, for example GL_NORMAL_ARRAY_BUFFER_BINDING.)[GL 2.1]. While a non-zero buffer object is bound to the GL_ARRAY_BUFFER target, the vertex array pointer parameter (that is traditionally interpreted as a pointer to client-side memory)[omited in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, the indices parameter of glDrawElements (that is traditionally interpreted as a pointer to client-side memory)[omitted in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

A buffer object binding created with glBindBuffer remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with glDeleteBuffers.

Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - buffer is not a name previously returned from a call to glGenBuffers. [GL 4 only]

associated gets:
    glGet with argument GL_ARRAY_BUFFER_BINDING
    glGet with argument GL_ELEMENT_ARRAY_BUFFER_BINDING












glBindTexture — bind a named texture to a texturing target
    void glBindTexture(GLenum target, GLuint texture);

target:
    Specifies the target (of the active texture unit)[only GL ES 2.0] to which the texture is bound. Must be either GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP. Limitation as per GL ES 2.0
texture:
    Specifies the name of a texture.

glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP and texture set to the name of the new texture binds the texture name to the target (of the current active texture unit)[GL ES 2.0 only]. When a texture is bound to a target, the previous binding for that target is automatically broken.

Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared (object space)[GL ES 2.0, GL 4]/(display-list space (see glXCreateContext))[GL 2.1] of the current GL rendering context(; two rendering contexts share texture names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in GL ES 2.0].

You (may)[GL 2.1, ES 2.0]/(must)[GL 4] use glGenTextures to generate a set of new texture names.

When a texture is first bound, it assumes the specified target: A texture first bound to GL_TEXTURE_2D becomes a two-dimensional texture and a texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped texture. The state of a two-dimensional texture immediately after it is first bound is equivalent to the state of the default GL_TEXTURE_2D at GL initialization, and similarly for cube-mapped textures.

While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. (If texture mapping is active on the target to which a texture is bound, the bound texture is used.)[GL 2.1 only] In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.

A texture binding created with glBindTexture remains active until a different texture is bound to the same target, or until the bound texture is deleted with glDeleteTextures.

Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use glBindTexture to bind an existing named texture to one of the texture targets than it is to reload the texture image using glTexImage2D. (For additional control over performance, use glPrioritizeTextures. glBindTexture is included in display lists. )[GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - texture is not a name returned from a previous call to glGenTextures.  [GL 4 only]
    GL_INVALID_OPERATION is generated if
        - texture was previously created with a target that doesn't match that of target.

associated gets:
    glGet with argument GL_TEXTURE_BINDING_2D or GL_TEXTURE_BINDING_CUBE_MAP







glBlendColor — set the blend color
    void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); [GL ES 2.0, GL 2.1]
    void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); [GL 4]

red, green, blue, alpha:
    specify the components of GL_BLEND_COLOR

The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The color components are clamped to the range [0, 1] before being stored. See glBlendFunc for a complete description of the blending operations. Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0).

Notes:

glBlendColor is part of the ARB_imaging subset. glBlendColor is present only if ARB_imaging is returned when glGetString is called with GL_EXTENSIONS as its argument. [GL 2.1 only]

The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

assigned gets:
    glGet with an argument of GL_BLEND_COLOR






glBlendEquation — specify the equation used for both the RGB blend equation and the Alpha blend equation
    void glBlendEquation(GLenum mode);

mode:
    specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT. Limitation as per GL ES 2.0

The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation.

These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA




glBlendEquationSeparate — set the RGB blend equation and the alpha blend equation separately
    void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);

modeRGB:
    specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.
modeAlpha:
    specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function specifies one blend equation for the RGB-color components and one blend equation for the alpha component.

The blend equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA






glBlendFunc — specify pixel arithmetic
    void glBlendFunc(GLenum sfactor, GLenum dfactor);

sfactor:
     Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.

dfactor:
    Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.

(In RGBA mode,)[only GL 2.1] Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending.

glBlendFunc defines the operation of blending when it is enabled. sfactor specifies which method is used to scale the source color components. dfactor specifies which method is used to scale the destination color components. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, source and destination color components are referred to as (Rs, Gs, Bs, As) and (Rd, Gd, Bd, Ad). The color specified by glBlendColor is referred to as (Rc, Gc, Bc, Ac). They are understood to have integer values between 0 and (kR, kG, kB, kA), where

kc = 2^mc - 1

and (mR, mG, mB, mA) is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as (sR, sG, sB, sA) and dR dG dB dA. The scale factors described in the table, denoted (fR, fG, fB, fA), represent either source or destination factors. All scale factors have range [0, 1].

Parameter 	                     (fR, fG, fB, fA)
GL_ZERO 	                     (0, 0, 0, 0)
GL_ONE 	                         (1, 1, 1, 1)
GL_SRC_COLOR 	                 (Rs/kR, Gs/kG, Bs/kB, As/kA)
GL_ONE_MINUS_SRC_COLOR 	         (1, 1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB, As/kA)
GL_DST_COLOR 	                 (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
GL_ONE_MINUS_DST_COLOR 	         (1, 1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
GL_SRC_ALPHA 	                 (As/kA, As/kA, As/kA, As/kA)
GL_ONE_MINUS_SRC_ALPHA 	         (1, 1, 1, 1) - (As/kA, As/kA, As/kA, As/kA)
GL_DST_ALPHA 	                 (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
GL_ONE_MINUS_DST_ALPHA 	         (1, 1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
GL_CONSTANT_COLOR 	             (Rc, Gc, Bc, Ac)
GL_ONE_MINUS_CONSTANT_COLOR 	 (1, 1, 1, 1) - (Rc, Gc, Bc, Ac)
GL_CONSTANT_ALPHA 	             (Ac, Ac, Ac, Ac)
GL_ONE_MINUS_CONSTANT_ALPHA 	 (1, 1, 1, 1) - (Ac, Ac, Ac, Ac)
GL_SRC_ALPHA_SATURATE 	         (i, i, i, 1)

In the table,

i = min(As, kA - Ad)/kA

To determine the blended RGBA values of a pixel (when drawing in RGBA mode)[only GL 2.1], the system uses (one of the equations set by glBlendEquation or glBlendEquationSeparate.)[GL ES 2.0]/(the following equations: Rd = min(kR,(Rs*sR)+(Rd*dR)), Gd = min(kG,(Gs*sG)+(Gd*dG)), Bd=min(kB,(Bs*sB)+(Bd*dB)), Ad=min(kA,(As*sA)+(Ad*dA)))[GL 2.1, GL 4]

(Despite the apparent precision of the above equations,)[omitted in GL ES 2.0] Blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. (For example, when sfactor is GL_SRC_ALPHA, dfactor is GL_ONE_MINUS_SRC_ALPHA, and A s is equal to k A , the equations reduce to simple replacement: Rd = Rs, Gd = Gs, Bd = Bs, Ad = As)[omitted in GL ES 2.0]

Examples

Transparency is best implemented using blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) with primitives sorted from farthest to nearest. Note that this transparency calculation does not require the presence of alpha bitplanes in the frame buffer.

(Blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) is also useful for rendering antialiased points and lines in arbitrary order.

Polygon antialiasing is optimized using blend function (GL_SRC_ALPHA_SATURATE, GL_ONE) with polygons sorted from nearest to farthest. (See the glEnable, glDisable reference page and the GL_POLYGON_SMOOTH argument for information on polygon antialiasing.) Destination alpha bitplanes, which must be present for this blend function to operate correctly, store the accumulated coverage.)[omitted in GL ES 2.0]

Notes

Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency.

(Blending affects only RGBA rendering. It is ignored by color index renderers.)[only GL 2.1]

errors:
    GL_INVALID_ENUM is generated if
        - either sfactor or dfactor is not an accepted value.

associated gets:
    glGet with argument GL_BLEND_SRC_RGB or GL_BLEND_SRC_ALPHA
    glGet with argument GL_BLEND_SRC [only GL 2.1]
    glGet with argument GL_BLEND_DST_RGB or GL_BLEND_DST_ALPHA
    glGet with argument GL_BLEND_DST [only GL 2.1]
    glIsEnabled with argument GL_BLEND








glBlendFuncSeparate — specify pixel arithmetic for RGB and alpha components separately
    void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

srcRGB:
    Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.

dstRGB:
    Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.

srcAlpha:
    Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. The initial value is GL_ONE.

dstAlpha:
    Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO.



(In RGBA mode,)[only GL 2.1] Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending.

glBlendFuncSeparate defines the operation of blending when it is enabled. srcRGB specifies which method is used to scale the source RGB-color components. dstRGB specifies which method is used to scale the destination RGB-color components. Likewise, srcAlpha specifies which method is used to scale the source alpha color component, and dstAlpha specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.

In the table and in subsequent equations, source and destination color components are referred to as (Rs, Gs, Bs, As) and (Rd, Gd, Bd, Ad). The color specified by glBlendColor is referred to as (Rc, Gc, Bc, Ac). They are understood to have integer values between 0 and (kR, kG, kB, kA), where

kc = 2^mc - 1

and (mR, mG, mB, mA) is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as (sR, sG, sB, sA) and dR dG dB dA. All scale factors have range [0, 1].

Parameter 	                     RGB Factor 	                                   Alpha Factor
GL_ZERO 	                     (0, 0, 0)                                         0
GL_ONE 	                         (1, 1, 1)                                         1
GL_SRC_COLOR 	                 (Rs/kR, Gs/kG, Bs/kB)                             As/kA
GL_ONE_MINUS_SRC_COLOR 	         (1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB)                 1 - As/kA
GL_DST_COLOR 	                 (Rd/kR, Gd/kG, Bd/kB)                             Ad/kA
GL_ONE_MINUS_DST_COLOR 	         (1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB)                 1 - Ad/kA
GL_SRC_ALPHA 	                 (As/kA, As/kA, As/kA)                             As/kA
GL_ONE_MINUS_SRC_ALPHA 	         (1, 1, 1) - (As/kA, As/kA, As/kA)                 1 - As/kA
GL_DST_ALPHA 	                 (Ad/kA, Ad/kA, Ad/kA)                             Ad/kA
GL_ONE_MINUS_DST_ALPHA 	         (1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA)                 1 - Ad/kA
GL_CONSTANT_COLOR 	             (Rc, Gc, Bc)                                      Ac
GL_ONE_MINUS_CONSTANT_COLOR 	 (1, 1, 1) - (Rc, Gc, Bc)                          1 - Ac
GL_CONSTANT_ALPHA 	             (Ac, Ac, Ac)                                      Ac
GL_ONE_MINUS_CONSTANT_ALPHA 	 (1, 1, 1) - (Ac, Ac, Ac)                          1 - Ac
GL_SRC_ALPHA_SATURATE 	         (i, i, i)                                         1

In the table,

i = min(As, kA - Ad)/kA

To determine the blended RGBA values of a pixel (when drawing in RGBA mode)[only GL 2.1], the system uses (one of the equations set by glBlendEquation or glBlendEquationSeparate.)[GL ES 2.0]/(the following equations: Rd = min(kR,(Rs*sR)+(Rd*dR)), Gd = min(kG,(Gs*sG)+(Gd*dG)), Bd=min(kB,(Bs*sB)+(Bd*dB)), Ad=min(kA,(As*sA)+(Ad*dA)))[GL 2.1, GL 4]

Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. (For example, when sfactor is GL_SRC_ALPHA, dfactor is GL_ONE_MINUS_SRC_ALPHA, and A s is equal to k A , the equations reduce to simple replacement: Rd = Rs, Gd = Gs, Bd = Bs, Ad = As)[omitted in GL ES 2.0]

Notes

Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency.

(Blending affects only RGBA rendering. It is ignored by color index renderers.)[only GL 2.1]

errors:
    GL_INVALID_ENUM is generated if
        - srcRGB, dstRGB, srcAlpha, or dstAlpha is not an accepted value. [according to ref, GL 2.1 and GL 4 doesn't give an error for incorrect srcAlpha and dstAlpha]

associated gets:
    glGet with argument GL_BLEND_SRC_RGB
    glGet with argument GL_BLEND_SRC_ALPHA
    glGet with argument GL_BLEND_DST_RGB
    glGet with argument GL_BLEND_DST_ALPHA
    glIsEnabled with argument GL_BLEND











glBufferData — create and initialize a buffer object's data store
    void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage);

target:
    Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER. Limitation as per GL ES 2.0

size:
    Specifies the size in bytes of the buffer object's new data store.

data:
    Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.

usage:
    Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STATIC_DRAW, or GL_DYNAMIC_DRAW. Limitation as per GL ES 2.0

glBufferData creates a new data store for the buffer object currently bound to target. (While creating the new storage,)[GL ES 2.0] Any pre-existing data store is deleted. The new data store is created with the specified size in bytes and usage. If data is not NULL, the data store is initialized with data from this pointer. (In its initial state, the new data store is not mapped, it has a NULL mapped pointer, and its mapped access is GL_READ_WRITE.)[omitted in GL ES 2.0]

usage is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. usage can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these:

STREAM
    The data store contents will be modified once and used at most a few times.

STATIC
    The data store contents will be modified once and used many times.

DYNAMIC
    The data store contents will be modified repeatedly and used many times.

The nature of access must be: [Limitation as per GL ES 2.0]

DRAW
    The data store contents are modified by the application, and used as the source for GL drawing and image specification commands.


Notes

If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.

Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N (bytes)[omitted in GL ES 2.0] be a multiple of N.

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
        - usage is not GL_STREAM_DRAW, GL_STATIC_DRAW, or GL_DYNAMIC_DRAW.
    GL_INVALID_VALUE is generated if
        - size is negative.
    GL_INVALID_OPERATION is generated if
        - the reserved buffer object name 0 is bound to target.
    GL_OUT_OF_MEMORY is generated if
        - the GL is unable to create a data store with the specified size.

associated gets:
    glGetBufferSubData [omitted in GL ES 2.0]
    glGetBufferParameteriv with argument GL_BUFFER_SIZE or GL_BUFFER_USAGE











glBufferSubData — update a subset of a buffer object's data store
    void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);

target
    Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.

offset
    Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.

size
    Specifies the size in bytes of the data store region being replaced.

data
    Specifies a pointer to the new data that will be copied into the data store.

glBufferSubData redefines some or all of the data store for the buffer object currently bound to target. Data starting at byte offset offset and extending for size bytes is copied to the data store from the memory pointed to by data. An error is thrown if offset and size together define a range beyond the bounds of the buffer object's data store.

Notes

When replacing the entire data store, consider using glBufferSubData rather than completely recreating the data store with glBufferData. This avoids the cost of reallocating the data store.

Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by glBufferSubData, especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated.

Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N (bytes)[omitted in GL ES 2.0] be a multiple of N.

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
    GL_INVALID_VALUE is generated if
        - offset or size is negative, or if (together they define a region of memory that extends beyond the buffer object's allocated data store)[GL ES 2.0, GL 2.1]/(offset+size is greater than the value of GL_BUFFER_SIZE for the specified buffer object)[GL 4].
    GL_INVALID_OPERATION is generated if
        - the reserved buffer object name 0 is bound to target.
        - if the buffer object being updated is mapped.  [only GL 2.1]
        - GL_INVALID_OPERATION is generated if the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set. [only GL 4]






