Common OpenGL Subset Documentation

Documentation of the common OpenGL subset. This includes the intersection of the OpenGL 2.1, OpenGL ES 2.0 and OpenGL 4 Reference Pages by Khronos, and describes therefore a commonly usable GL API.





glActiveTexture — select active texture unit
    void glActiveTexture(GLenum texture);

texture:
    Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.

glActiveTexture selects which texture unit subsequent texture state calls will affect. The number of texture units an implementation supports is implementation dependent, but must be at least 2 as per GL 2.1.

errors:
    GL_INVALID_ENUM is generated if
        - texture is not one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS-1).

associated gets:
    glGet with argument GL_ACTIVE_TEXTURE or GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS





glAttachShader — attach a shader object to a program object
    void glAttachShader(GLuint program, GLuint shader);

program:
    Specifies the program object to which a shader object will be attached.
shader:
    Specifies the shader object that is to be attached.

In order to create an executable/a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. glAttachShader attaches the shader object specified by shader to the program object specified by program. This indicates that shader will be included in link operations that will be performed on program.

All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. Multiple shader objects of the same type may not be attached to a single program object as per GL ES 2.9. However, a single shader object may be attached to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until glDetachShader is called to detach it from all program objects to which it is attached.

errors:
    GL_INVALID_VALUE is generated if
        - either program or shader is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - shader is not a shader object.
        - shader is already attached to program, or
        - (in ES 2.0 only) another shader object of the same type as shader is already attached to program.

associated gets:
    glGetAttachedShaders with the handle of a valid program object
    glIsProgram
    glIsShader








glBindAttribLocation — associate a generic vertex attribute index with a named attribute variable
    void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);

program:
    Specifies the handle of the program object in which the association is to be made.
index:
    Specifies the index of the generic vertex attribute to be bound.
name:
    Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.

glBindAttribLocation is used to associate a user-defined attribute variable in the program object specified by program with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in name. The generic vertex attribute index to be bound to this variable is specified by index. When program is made part of current state, values provided via the generic vertex attribute index will modify the value of the user-defined attribute variable specified by name.

If name refers to a matrix attribute variable, index refers to the first column of the matrix. Other matrix columns are then automatically bound to locations index+1 for a matrix of type mat2; index+1 and index+2 for a matrix of type mat3; and index+1, index+2, and index+3 for a matrix of type mat4.

This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from 0 to GL_MAX_VERTEX_ATTRIBS -1. The values sent to each generic attribute index are part of current state, (just like standard vertex attributes such as color, normal, and vertex position)[omitted in GL4]. If a different program object is made current by calling glUseProgram, the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to index.

Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling glBindAttribLocation. Attribute bindings do not go into effect until glLinkProgram is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs.

(Applications are not allowed to bind any of the standard OpenGL vertex attributes using this command, as they are bound automatically when needed.)[omitted in GL4] Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.


Notes

glBindAttribLocation can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.

If name was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index.

Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called aliasing, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing. (Because there is no way to bind standard attributes, it is not possible to alias generic attributes with conventional ones (except for generic attribute 0).)[omitted in GL4]

Active attributes that are not explicitly bound will be bound by the linker when glLinkProgram is called. The locations assigned can be queried by calling glGetAttribLocation.

OpenGL copies the name string when glBindAttribLocation is called, so an application may free its copy of the name string immediately after the function returns.

errors:
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
        - program is not a value generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - name starts with the reserved prefix "gl_".
        - program is not a program object.

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS
    glGetActiveAttrib with argument program
    glGetAttribLocation with arguments program and name
    glIsProgram











glBindBuffer — bind a named buffer object
    void glBindBuffer(GLenum target, GLuint buffer);

target:
    Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER [purpose: Vertex attributes, according to GL4] or GL_ELEMENT_ARRAY_BUFFER [purpose: Vertex array indices, according to GL4]. Limitation as per GL ES 2.0.
buffer:
    Specifies the name of a buffer object.

glBindBuffer lets you create or use a named buffer object. Calling glBindBuffer with target set to GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER and buffer set to the name of the new buffer object binds the buffer object name to the target. (If no buffer object with name buffer exists, one is created with that name.)[GL4 only] When a buffer object is bound to a target, the previous binding for that target is automatically broken.

Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target ((if supported for that target))[GL 4 only]. Buffer object names and the corresponding buffer object contents are local to the shared (object space)[as per ES 2.0 and GL4]/(display-list space (see glXCreateContext))[as per GL 2.1] of the current GL rendering context(; two rendering contexts share buffer object names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in ES 2.0]

(You may use glGenBuffers to generate a set of new buffer object names.)[GL ES 2.0, GL 2.1]/(glGenBuffers must be used to generate a set of unused buffer object names.)[GL 4]

The state of a buffer object immediately after it is first bound is a[n] (unmapped)[omitted in GL ES 2.0] zero-sized memory buffer with (GL_READ_WRITE access and)[omitted in GL ES 2.0] GL_STATIC_DRAW usage.

While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an GL_INVALID_OPERATION error.

When vertex array pointer state is changed (by a call to glVertexAttribPointer)[ES 2.0]/(for example by a call to glNormalPointer)[GL 2.1], the current buffer object binding (GL_ARRAY_BUFFER_BINDING) is copied into the corresponding client state for (the vertex attrib array being changed, one of the indexed GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDINGs)[ES 2.0]/(vertex array type being changed, for example GL_NORMAL_ARRAY_BUFFER_BINDING.)[GL 2.1]. While a non-zero buffer object is bound to the GL_ARRAY_BUFFER target, the vertex array pointer parameter (that is traditionally interpreted as a pointer to client-side memory)[omited in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, the indices parameter of glDrawElements (that is traditionally interpreted as a pointer to client-side memory)[omitted in GL4] is instead interpreted as an offset within the buffer object measured in basic machine units.

A buffer object binding created with glBindBuffer remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with glDeleteBuffers.

Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - buffer is not a name previously returned from a call to glGenBuffers. [GL 4 only]

associated gets:
    glGet with argument GL_ARRAY_BUFFER_BINDING
    glGet with argument GL_ELEMENT_ARRAY_BUFFER_BINDING












glBindTexture — bind a named texture to a texturing target
    void glBindTexture(GLenum target, GLuint texture);

target:
    Specifies the target (of the active texture unit)[only GL ES 2.0] to which the texture is bound. Must be either GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP. Limitation as per GL ES 2.0
texture:
    Specifies the name of a texture.

glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP and texture set to the name of the new texture binds the texture name to the target (of the current active texture unit)[GL ES 2.0 only]. When a texture is bound to a target, the previous binding for that target is automatically broken.

Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared (object space)[GL ES 2.0, GL 4]/(display-list space (see glXCreateContext))[GL 2.1] of the current GL rendering context(; two rendering contexts share texture names only if they (also share display lists)[GL 2.1]/(explicitly enable sharing between contexts through the appropriate GL windows interfaces functions)[GL 4].)[omitted in GL ES 2.0].

You (may)[GL 2.1, ES 2.0]/(must)[GL 4] use glGenTextures to generate a set of new texture names.

When a texture is first bound, it assumes the specified target: A texture first bound to GL_TEXTURE_2D becomes a two-dimensional texture and a texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped texture. The state of a two-dimensional texture immediately after it is first bound is equivalent to the state of the default GL_TEXTURE_2D at GL initialization, and similarly for cube-mapped textures.

While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. (If texture mapping is active on the target to which a texture is bound, the bound texture is used.)[GL 2.1 only] In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.

A texture binding created with glBindTexture remains active until a different texture is bound to the same target, or until the bound texture is deleted with glDeleteTextures.

Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use glBindTexture to bind an existing named texture to one of the texture targets than it is to reload the texture image using glTexImage2D. (For additional control over performance, use glPrioritizeTextures. glBindTexture is included in display lists. )[GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - target is not one of the allowable values.
    GL_INVALID_VALUE is generated if
        - texture is not a name returned from a previous call to glGenTextures.  [GL 4 only]
    GL_INVALID_OPERATION is generated if
        - texture was previously created with a target that doesn't match that of target.

associated gets:
    glGet with argument GL_TEXTURE_BINDING_2D or GL_TEXTURE_BINDING_CUBE_MAP







glBlendColor — set the blend color
    void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); [GL ES 2.0, GL 2.1]
    void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); [GL 4]

red, green, blue, alpha:
    specify the components of GL_BLEND_COLOR

The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The color components are clamped to the range [0, 1] before being stored. See glBlendFunc for a complete description of the blending operations. Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0).

Notes:

glBlendColor is part of the ARB_imaging subset. glBlendColor is present only if ARB_imaging is returned when glGetString is called with GL_EXTENSIONS as its argument. [GL 2.1 only]

The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

assigned gets:
    glGet with an argument of GL_BLEND_COLOR






glBlendEquation — specify the equation used for both the RGB blend equation and the Alpha blend equation
    void glBlendEquation(GLenum mode);

mode:
    specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT. Limitation as per GL ES 2.0

The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation.

These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA




glBlendEquationSeparate — set the RGB blend equation and the alpha blend equation separately
    void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);

modeRGB:
    specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.
modeAlpha:
    specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function specifies one blend equation for the RGB-color components and one blend equation for the alpha component.

The blend equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as Rs Gs Bs As and Rd Gd Bd Ad, respectively. The result color is referred to as Rr Gr Br Ar . The source and destination blend factors are denoted sR sG sB sA and dR dG dB dA , respectively. For these equations all color components are understood to have values in the range 0 1 .


Mode 	                            RGB Components 	                    Alpha Component
                                    Rr = (Rs * sR) + (Rd * dR)
GL_FUNC_ADD                         Gr = (Gs * sG) + (Gd * dG)          Ar = (As * sA) + (Ad * dA)
                                    Br = (Bs * sB) + (Bd * dB)

                                    Rr = (Rs * sR) - (Rd * dR)
GL_FUNC_SUBTRACT 	                Gr = (Gs * sG) - (Gd * dG)          Ar = (As * sA) - (Ad * dA)
                                    Br = (Bs * sB) - (Bd * dB)

                                    Rr = (Rd * dR) - (Rs * sR)
GL_FUNC_REVERSE_SUBTRACT            Gr = (Gd * dG) - (Gs * sG)          Ar = (Ad * dA) - (As * sA)
                                    Br = (Bd * dB) - (Bs * sB)

The results of these equations are clamped to the range 0 1 .

The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.

errors:
    GL_INVALID_ENUM is generated if
        - modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, or GL_FUNC_REVERSE_SUBTRACT.

assigned gets:
    glGet with an argument of GL_BLEND_EQUATION_RGB
    glGet with an argument of GL_BLEND_EQUATION_ALPHA






glBlendFunc — specify pixel arithmetic
    void glBlendFunc(GLenum sfactor, GLenum dfactor);

sfactor:
     Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.

dfactor:
    Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.

(In RGBA mode,)[only GL 2.1] Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending.

glBlendFunc defines the operation of blending when it is enabled. sfactor specifies which method is used to scale the source color components. dfactor specifies which method is used to scale the destination color components. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, source and destination color components are referred to as (Rs, Gs, Bs, As) and (Rd, Gd, Bd, Ad). The color specified by glBlendColor is referred to as (Rc, Gc, Bc, Ac). They are understood to have integer values between 0 and (kR, kG, kB, kA), where

kc = 2^mc - 1

and (mR, mG, mB, mA) is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as (sR, sG, sB, sA) and dR dG dB dA. The scale factors described in the table, denoted (fR, fG, fB, fA), represent either source or destination factors. All scale factors have range [0, 1].

Parameter 	                     (fR, fG, fB, fA)
GL_ZERO 	                     (0, 0, 0, 0)
GL_ONE 	                         (1, 1, 1, 1)
GL_SRC_COLOR 	                 (Rs/kR, Gs/kG, Bs/kB, As/kA)
GL_ONE_MINUS_SRC_COLOR 	         (1, 1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB, As/kA)
GL_DST_COLOR 	                 (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
GL_ONE_MINUS_DST_COLOR 	         (1, 1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
GL_SRC_ALPHA 	                 (As/kA, As/kA, As/kA, As/kA)
GL_ONE_MINUS_SRC_ALPHA 	         (1, 1, 1, 1) - (As/kA, As/kA, As/kA, As/kA)
GL_DST_ALPHA 	                 (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
GL_ONE_MINUS_DST_ALPHA 	         (1, 1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
GL_CONSTANT_COLOR 	             (Rc, Gc, Bc, Ac)
GL_ONE_MINUS_CONSTANT_COLOR 	 (1, 1, 1, 1) - (Rc, Gc, Bc, Ac)
GL_CONSTANT_ALPHA 	             (Ac, Ac, Ac, Ac)
GL_ONE_MINUS_CONSTANT_ALPHA 	 (1, 1, 1, 1) - (Ac, Ac, Ac, Ac)
GL_SRC_ALPHA_SATURATE 	         (i, i, i, 1)

In the table,

i = min(As, kA - Ad)/kA

To determine the blended RGBA values of a pixel (when drawing in RGBA mode)[only GL 2.1], the system uses (one of the equations set by glBlendEquation or glBlendEquationSeparate.)[GL ES 2.0]/(the following equations: Rd = min(kR,(Rs*sR)+(Rd*dR)), Gd = min(kG,(Gs*sG)+(Gd*dG)), Bd=min(kB,(Bs*sB)+(Bd*dB)), Ad=min(kA,(As*sA)+(Ad*dA)))[GL 2.1, GL 4]

(Despite the apparent precision of the above equations,)[omitted in GL ES 2.0] Blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. (For example, when sfactor is GL_SRC_ALPHA, dfactor is GL_ONE_MINUS_SRC_ALPHA, and A s is equal to k A , the equations reduce to simple replacement: Rd = Rs, Gd = Gs, Bd = Bs, Ad = As)[omitted in GL ES 2.0]

Examples

Transparency is best implemented using blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) with primitives sorted from farthest to nearest. Note that this transparency calculation does not require the presence of alpha bitplanes in the frame buffer.

(Blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) is also useful for rendering antialiased points and lines in arbitrary order.

Polygon antialiasing is optimized using blend function (GL_SRC_ALPHA_SATURATE, GL_ONE) with polygons sorted from nearest to farthest. (See the glEnable, glDisable reference page and the GL_POLYGON_SMOOTH argument for information on polygon antialiasing.) Destination alpha bitplanes, which must be present for this blend function to operate correctly, store the accumulated coverage.)[omitted in GL ES 2.0]

Notes

Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency.

(Blending affects only RGBA rendering. It is ignored by color index renderers.)[only GL 2.1]

errors:
    GL_INVALID_ENUM is generated if
        - either sfactor or dfactor is not an accepted value.

associated gets:
    glGet with argument GL_BLEND_SRC_RGB or GL_BLEND_SRC_ALPHA
    glGet with argument GL_BLEND_SRC [only GL 2.1]
    glGet with argument GL_BLEND_DST_RGB or GL_BLEND_DST_ALPHA
    glGet with argument GL_BLEND_DST [only GL 2.1]
    glIsEnabled with argument GL_BLEND








glBlendFuncSeparate — specify pixel arithmetic for RGB and alpha components separately
    void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

srcRGB:
    Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.

dstRGB:
    Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.

srcAlpha:
    Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. The initial value is GL_ONE.

dstAlpha:
    Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO.



(In RGBA mode,)[only GL 2.1] Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending.

glBlendFuncSeparate defines the operation of blending when it is enabled. srcRGB specifies which method is used to scale the source RGB-color components. dstRGB specifies which method is used to scale the destination RGB-color components. Likewise, srcAlpha specifies which method is used to scale the source alpha color component, and dstAlpha specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.

In the table and in subsequent equations, source and destination color components are referred to as (Rs, Gs, Bs, As) and (Rd, Gd, Bd, Ad). The color specified by glBlendColor is referred to as (Rc, Gc, Bc, Ac). They are understood to have integer values between 0 and (kR, kG, kB, kA), where

kc = 2^mc - 1

and (mR, mG, mB, mA) is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as (sR, sG, sB, sA) and dR dG dB dA. All scale factors have range [0, 1].

Parameter 	                     RGB Factor 	                                   Alpha Factor
GL_ZERO 	                     (0, 0, 0)                                         0
GL_ONE 	                         (1, 1, 1)                                         1
GL_SRC_COLOR 	                 (Rs/kR, Gs/kG, Bs/kB)                             As/kA
GL_ONE_MINUS_SRC_COLOR 	         (1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB)                 1 - As/kA
GL_DST_COLOR 	                 (Rd/kR, Gd/kG, Bd/kB)                             Ad/kA
GL_ONE_MINUS_DST_COLOR 	         (1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB)                 1 - Ad/kA
GL_SRC_ALPHA 	                 (As/kA, As/kA, As/kA)                             As/kA
GL_ONE_MINUS_SRC_ALPHA 	         (1, 1, 1) - (As/kA, As/kA, As/kA)                 1 - As/kA
GL_DST_ALPHA 	                 (Ad/kA, Ad/kA, Ad/kA)                             Ad/kA
GL_ONE_MINUS_DST_ALPHA 	         (1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA)                 1 - Ad/kA
GL_CONSTANT_COLOR 	             (Rc, Gc, Bc)                                      Ac
GL_ONE_MINUS_CONSTANT_COLOR 	 (1, 1, 1) - (Rc, Gc, Bc)                          1 - Ac
GL_CONSTANT_ALPHA 	             (Ac, Ac, Ac)                                      Ac
GL_ONE_MINUS_CONSTANT_ALPHA 	 (1, 1, 1) - (Ac, Ac, Ac)                          1 - Ac
GL_SRC_ALPHA_SATURATE 	         (i, i, i)                                         1

In the table,

i = min(As, kA - Ad)/kA

To determine the blended RGBA values of a pixel (when drawing in RGBA mode)[only GL 2.1], the system uses (one of the equations set by glBlendEquation or glBlendEquationSeparate.)[GL ES 2.0]/(the following equations: Rd = min(kR,(Rs*sR)+(Rd*dR)), Gd = min(kG,(Gs*sG)+(Gd*dG)), Bd=min(kB,(Bs*sB)+(Bd*dB)), Ad=min(kA,(As*sA)+(Ad*dA)))[GL 2.1, GL 4]

Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. (For example, when sfactor is GL_SRC_ALPHA, dfactor is GL_ONE_MINUS_SRC_ALPHA, and A s is equal to k A , the equations reduce to simple replacement: Rd = Rs, Gd = Gs, Bd = Bs, Ad = As)[omitted in GL ES 2.0]

Notes

Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency.

(Blending affects only RGBA rendering. It is ignored by color index renderers.)[only GL 2.1]

errors:
    GL_INVALID_ENUM is generated if
        - srcRGB, dstRGB, srcAlpha, or dstAlpha is not an accepted value. [according to ref, GL 2.1 and GL 4 doesn't give an error for incorrect srcAlpha and dstAlpha]

associated gets:
    glGet with argument GL_BLEND_SRC_RGB
    glGet with argument GL_BLEND_SRC_ALPHA
    glGet with argument GL_BLEND_DST_RGB
    glGet with argument GL_BLEND_DST_ALPHA
    glIsEnabled with argument GL_BLEND











glBufferData — create and initialize a buffer object's data store
    void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage);

target:
    Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER. Limitation as per GL ES 2.0

size:
    Specifies the size in bytes of the buffer object's new data store.

data:
    Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.

usage:
    Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STATIC_DRAW, or GL_DYNAMIC_DRAW. Limitation as per GL ES 2.0

glBufferData creates a new data store for the buffer object currently bound to target. (While creating the new storage,)[GL ES 2.0] Any pre-existing data store is deleted. The new data store is created with the specified size in bytes and usage. If data is not NULL, the data store is initialized with data from this pointer. (In its initial state, the new data store is not mapped, it has a NULL mapped pointer, and its mapped access is GL_READ_WRITE.)[omitted in GL ES 2.0]

usage is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. usage can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these:

STREAM
    The data store contents will be modified once and used at most a few times.

STATIC
    The data store contents will be modified once and used many times.

DYNAMIC
    The data store contents will be modified repeatedly and used many times.

The nature of access must be: [Limitation as per GL ES 2.0]

DRAW
    The data store contents are modified by the application, and used as the source for GL drawing and image specification commands.


Notes

If data is NULL, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.

Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N (bytes)[omitted in GL ES 2.0] be a multiple of N.

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
        - usage is not GL_STREAM_DRAW, GL_STATIC_DRAW, or GL_DYNAMIC_DRAW.
    GL_INVALID_VALUE is generated if
        - size is negative.
    GL_INVALID_OPERATION is generated if
        - the reserved buffer object name 0 is bound to target.
    GL_OUT_OF_MEMORY is generated if
        - the GL is unable to create a data store with the specified size.

associated gets:
    glGetBufferSubData [omitted in GL ES 2.0]
    glGetBufferParameteriv with argument GL_BUFFER_SIZE or GL_BUFFER_USAGE











glBufferSubData — update a subset of a buffer object's data store
    void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);

target
    Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.

offset
    Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.

size
    Specifies the size in bytes of the data store region being replaced.

data
    Specifies a pointer to the new data that will be copied into the data store.

glBufferSubData redefines some or all of the data store for the buffer object currently bound to target. Data starting at byte offset offset and extending for size bytes is copied to the data store from the memory pointed to by data. An error is thrown if offset and size together define a range beyond the bounds of the buffer object's data store.

Notes

When replacing the entire data store, consider using glBufferSubData rather than completely recreating the data store with glBufferData. This avoids the cost of reallocating the data store.

Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by glBufferSubData, especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated.

Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N (bytes)[omitted in GL ES 2.0] be a multiple of N.

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
    GL_INVALID_VALUE is generated if
        - offset or size is negative, or if (together they define a region of memory that extends beyond the buffer object's allocated data store)[GL ES 2.0, GL 2.1]/(offset+size is greater than the value of GL_BUFFER_SIZE for the specified buffer object)[GL 4].
    GL_INVALID_OPERATION is generated if
        - the reserved buffer object name 0 is bound to target.
        - if the buffer object being updated is mapped.  [only GL 2.1]
        - GL_INVALID_OPERATION is generated if the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set. [only GL 4]











glClear — clear buffers to preset values
    void glClear(GLbitfield mask);

mask:
    Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.

glClear sets the bitplane area of the window to values previously selected by glClearColor, glClearDepth[f], and glClearStencil.

The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of glClear. The scissor box bounds the cleared region. Blend function, stenciling, (fragment shading)[only in GL ES 2.0], and depth-buffering are ignored by glClear.

glClear takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.

The values are as follows:

GL_COLOR_BUFFER_BIT
    Indicates the buffers currently enabled for color writing.

GL_DEPTH_BUFFER_BIT
    Indicates the depth buffer.

GL_STENCIL_BUFFER_BIT
    Indicates the stencil buffer.

The value to which each buffer is cleared depends on the setting of the clear value for that buffer.

Notes

If a buffer is not present, then a glClear directed at that buffer has no effect.

errors:
    GL_INVALID_VALUE is generated if
        - any bit other than the three defined bits is set in mask.

associated gets:
    glGet with argument GL_DEPTH_CLEAR_VALUE
    glGet with argument GL_COLOR_CLEAR_VALUE
    glGet with argument GL_STENCIL_CLEAR_VALUE











glClearColor — specify clear values for the color buffers
    void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); [GL ES 2.0, GL 2.1]
    void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); [GL 4]

red, green, blue, alpha:
    Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.

glClearColor specifies the red, green, blue, and alpha values used by glClear to clear the color buffers. Values specified by glClearColor are clamped to the range [0, 1].

Notes

The type of the red, green, blue, and alpha parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

associated gets:
    glGet with argument GL_COLOR_CLEAR_VALUE








glClearDepth[f] — specify the clear value for the depth buffer
    void glClearDepthf(GLclampf depth); [in GL ES 2.0]
    void glClearDepthf(GLfloat depth); [in GL 4.1+]
    void glClearDepth(GLclampd depth); [in GL 2.1]
    void glClearDepth(GLdouble depth); [in GL 4]

depth:
    Specifies the depth value used when the depth buffer is cleared. The initial value is 1.

glClearDepth[f] specifies the depth value used by glClear to clear the depth buffer. Values specified by glClearDepth[f] are clamped to the range [0, 1].

Notes

The type of the depth parameter was changed from GLclampf to GLfloat for glClearDepthf and from GLclampd to GLdouble for glClearDepth. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

associated gets:
    glGet with argument GL_DEPTH_CLEAR_VALUE









glClearStencil — specify the clear value for the stencil buffer
    void glClearStencil(GLint s);

s:
    Specifies the index used when the stencil buffer is cleared. The initial value is 0.

glClearStencil specifies the index used by glClear to clear the stencil buffer. s is masked with 2^m - 1 ,where m is the number of bits in the stencil buffer.

associated gets:
    glGet with argument GL_STENCIL_CLEAR_VALUE
    glGet with argument GL_STENCIL_BITS









glColorMask — enable and disable writing of frame buffer color components
    void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

red, green, blue, alpha:
    Specify whether red, green, blue, and alpha can or cannot be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components can be written.

glColorMask specifies whether the individual color components in the frame buffer can or cannot be written. If red is GL_FALSE, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.

Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.

associated gets:
    glGet with argument GL_COLOR_WRITEMASK
    glGet with argument GL_RGBA_MODE [GL 2.1 only]










glCompileShader — compile a shader object
    void glCompileShader(GLuint shader);

shader:
    Specifies the shader object to be compiled.

(For implementations that support a shader compiler,)[GL ES 2.0 only] glCompileShader compiles the source code strings that have been stored in the shader object specified by shader.

The compilation status will be stored as part of the shader object's state. This value will be set to GL_TRUE if the shader was compiled without errors and is ready for use, and GL_FALSE otherwise. It can be queried by calling (glGetShaderiv)[GL ES 2.0]/(glGetShader)[GL 2.1, GL 4] with arguments shader and GL_COMPILE_STATUS.

Compilation of a shader can fail for a number of reasons as specified by the OpenGL (ES)[GL ES 2.0 only] Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling glGetShaderInfoLog.


Notes

Shader compiler support is optional, and thus must be queried before use by calling glGet with argument GL_SHADER_COMPILER. glShaderSource, glCompileShader, glGetShaderPrecisionFormat, and glReleaseShaderCompiler will each generate GL_INVALID_OPERATION on implementations that do not support a shader compiler. Such implementations instead offer the glShaderBinary alternative for supplying a pre-compiled shader binary. [GL ES 2.0 only]


errors:
    GL_INVALID_OPERATION is generated if
        - shader is not a shader object.
        - a shader compiler is not supported. [GL ES 2.0 only]
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.

associated gets:
    glGet with argument GL_SHADER_COMPILER [GL ES 2.0 only]
    glGetShaderInfoLog with argument shader
    (glGetShaderiv)[GL ES 2.0]/(glGetShader)[GL 2.1, GL 4] with arguments shader and GL_COMPILE_STATUS
    glIsShader














glCompressedTexImage2D — specify a two-dimensional texture image in a compressed format
    void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat,
        GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);

target
    Specifies the target texture (of the active texture unit)[GL ES 2.0 only]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. Limitation as per GL ES 2.0

level
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

internalformat
    Specifies the format of the compressed image data stored at address data.

width
    Specifies the width of the texture image (including the border if any)[only GL 2.1]. (If the GL version does not support non-power-of-two sizes, this value must be 2 n + 2 ⁡ border for some integer n.)[only GL 2.1] All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.

height
    Specifies the height of the texture image (including the border if any)[only GL 2.1]. (If the GL version does not support non-power-of-two sizes, this value must be Must be 2 n + 2 ⁡ border for some integer n.)[only GL 2.1] All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.

border
    Specifies the width of the border. Must be 0. Limitation as per GL ES 2.0 and GL 4

imageSize
    Specifies the number of unsigned bytes of image data starting at the address specified by data.

data
    Specifies a pointer to the compressed image data in memory.

Texturing (maps a portion of a specified texture image onto each graphical primitive for which texturing is (active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0]/(enabled. To enable and disable two-dimensional texturing, call glEnable and glDisable with argument GL_TEXTURE_2D. To enable and disable texturing using cube-mapped textures, call glEnable and glDisable with argument GL_TEXTURE_CUBE_MAP.)[GL 2.1])[GL ES 2.0, GL 2.1] / (allows elements of an image array to be read by shaders.)[GL 4]

(glCompressedTexImage2D defines a two-dimensional texture image or cube-map texture image using compressed image data from client memory. The texture image is decoded according to the extension specification defining the specified internalformat. OpenGL ES defines no specific compressed texture formats, but does provide a mechanism to obtain symbolic constants for such formats provided by extensions. The number of compressed texture formats supported can be obtained by querying the value of GL_NUM_COMPRESSED_TEXTURE_FORMATS. The list of specific compressed texture formats supported can be obtained by querying the value of GL_COMPRESSED_TEXTURE_FORMATS.
)[GL ES 2.0]

(glCompressedTexImage2D loads a previously defined, and retrieved, compressed two-dimensional texture image if target is GL_TEXTURE_2D(, or one of the cube map faces such as GL_TEXTURE_CUBE_MAP_POSITIVE_X.)[GL 4 only] (see glTexImage2D).

internalformat must be (a known compressed image format (such as GL_RGTC) or)[only GL 4] an extension-specified compressed-texture format. When a texture is loaded with glTexImage2D using a generic compressed texture format (e.g., GL_COMPRESSED_RGB), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using glCompressedTexImage2D, query the compressed texture image's size and format using glGetTexLevelParameter.

If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image is specified, data is treated as a byte offset into the buffer object's data store.
)[GL 2.1, GL 4]

(If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for glTexImage2D. In the following description, denote by bs, bw, bh, and bd, the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE, GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT, and GL_UNPACK_COMPRESSED_BLOCK_DEPTH, respectively. bs is the compressed block size in bytes; bw, bh, and bd are the compressed block width, height, and depth in pixels.

By default the pixel storage modes GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS and GL_UNPACK_ROW_LENGTH, bs and bw must both be non-zero. To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT, bh must be non-zero. To also enable GL_UNPACK_SKIP_IMAGES, bd must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.

When selecting a sub-rectangle from a compressed image:
 - The value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw;
 - the value of GL_UNPACK_SKIP_ROWS must be a multiple of bw.
imageSize must be equal to:
    bs * ceil(width/bw)*ceil(height/bh))[GL 4 only]



Notes

(A GL implementation may choose to store the texture array at any internal resolution it chooses.

glCompressedTexImage2D specifies a two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture.)[GL ES 2.0]



errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. [GL ES 2.0 only]
        - internalformat is not a supported format returned in GL_COMPRESSED_TEXTURE_FORMATS. [GL ES 2.0 only]
        - internalformat is one of the generic compressed internal formats: GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, or GL_COMPRESSED_RGBA. [GL 2.1 only]
        - internalformat is not one of the specific compressed internal formats: GL_COMPRESSED_RED_RGTC1, GL_COMPRESSED_SIGNED_RED_RGTC1, GL_COMPRESSED_RG_RGTC2, GL_COMPRESSED_SIGNED_RG_RGTC2. GL_COMPRESSED_RGBA_BPTC_UNORM, GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_RG11_EAC, or GL_COMPRESSED_SIGNED_RG11_EAC. [GL 4 only]
    GL_INVALID_VALUE is generated if
        - level is less than 0.  [GL ES 2.0 only]
        - width or height is less than 0 or greater than GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D. [GL ES 2.0 only]
        - border is not 0. [GL ES 2.0, GL 4]
        - imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data.
    GL_INVALID_VALUE may be generated if
        - level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.  [GL ES 2.0 only]
    GL_INVALID_OPERATION is generated if
        - parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. [GL 2.1, GL 4]
    Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format.


associated gets:
    glGet with arguments GL_NUM_COMPRESSED_TEXTURE_FORMATS and GL_COMPRESSED_TEXTURE_FORMATS [GL ES 2.0]
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0]
    (glGetCompressedTexImage
    glGet with argument GL_TEXTURE_COMPRESSED
    glGet with argument GL_PIXEL_UNPACK_BUFFER_BINDING
    glGetTexLevelParameter with arguments GL_TEXTURE_INTERNAL_FORMAT and GL_TEXTURE_COMPRESSED_IMAGE_SIZE) [GL 2.1 and GL 4]
    glIsEnabled with argument GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP [GL 2.1 only]











glCompressedTexSubImage2D — specify a two-dimensional texture subimage in a compressed format
    void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
        GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);

target
    Specifies the target (texture (of the active texture unit)[GL ES 2.0 only])[GL ES 2.0, GL 2.1]/(to which the texture is bound)[GL 4]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. Limitation as per GL ES 2.0 and GL 2.1

level
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

xoffset
    Specifies a texel offset in the x direction within the texture array.

yoffset
    Specifies a texel offset in the y direction within the texture array.

width
    Specifies the width of the texture subimage.

height
    Specifies the height of the texture subimage.

format
    Specifies the format of the compressed image data stored at address data.

imageSize
    Specifies the number of unsigned bytes of image data starting at the address specified by data.

data
    Specifies a pointer to the compressed image data in memory.

Texturing (maps a portion of a specified texture image onto each graphical primitive for which texturing is (active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0]/(enabled. To enable and disable two-dimensional texturing, call glEnable and glDisable with argument GL_TEXTURE_2D. To enable and disable texturing using cube-mapped textures, call glEnable and glDisable with argument GL_TEXTURE_CUBE_MAP.)[GL 2.1])[GL ES 2.0, GL 2.1] / (allows elements of an image array to be read by shaders.)[GL 4]

glCompressedTexSubImage2D redefines a contiguous subregion of an existing two-dimensional texture image. The texels referenced by data replace the portion of the existing texture array with x indices xoffset and xoffset + width - 1 , and the y indices yoffset and yoffset + height - 1 , inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.

(format)[GL ES 2.0, GL 2.1]/(internalformat)[GL 4] must be (the same extension-specified compressed-texture format previously specified by glCompressedTexImage2D.)[GL ES 2.0]/((a known compressed image format (such as GL_RGTC) or)[GL 4 only] an extension-specified compressed-texture format. The format of the compressed texture image is selected by the GL implementation that compressed it (see glTexImage2D) and should be queried at the time the texture was compressed with glGetTexLevelParameter.

If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target (see glBindBuffer) while a texture image is specified, data is treated as a byte offset into the buffer object's data store.)[GL 2.1, GL 4]

Notes

(glCompressedTexSubImage2D specifies a two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture.)[GL ES 2.0]


errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. [GL ES 2.0 only]
        - format is not a supported format returned in GL_COMPRESSED_TEXTURE_FORMATS. [GL ES 2.0 only]
        - format is one of these generic compressed internal formats: GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SLUMINANCE, GL_COMPRESSED_SLUMINANCE_ALPHA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGBA, or GL_COMPRESSED_SRGB_ALPHA. [GL 2.1 only]
        - internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. [GL 4 only]
        - target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE. [GL 4 only]
    GL_INVALID_VALUE is generated if
        - level is less than 0.  [GL ES 2.0 only]
        - xoffset < 0 , xoffset + width > w , yoffset < 0 , or yoffset + height > h , where w is the width and h is the height of the texture image being modified. [GL ES 2.0 only]
        - width or height is less than 0 [GL ES 2.0 only]
        - imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data.
    GL_INVALID_VALUE may be generated if
        - level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.  [GL ES 2.0 only]
    GL_INVALID_OPERATION is generated if
        - the texture array has not been defined by a previous glCompressedTexImage2D operation whose internalformat matches the format of glCompressedTexSubImage2D.[GL ES 2.0 only]
        - parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. [GL 2.1, GL 4]
    Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format.


associated gets:
    glGet with arguments GL_NUM_COMPRESSED_TEXTURE_FORMATS and GL_COMPRESSED_TEXTURE_FORMATS [GL ES 2.0]
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0]
    (glGetCompressedTexImage
    glGet with argument GL_TEXTURE_COMPRESSED
    glGet with argument GL_PIXEL_UNPACK_BUFFER_BINDING
    glGetTexLevelParameter with arguments GL_TEXTURE_INTERNAL_FORMAT and GL_TEXTURE_COMPRESSED_IMAGE_SIZE) [GL 2.1 and GL 4]
    glIsEnabled with argument GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP [GL 2.1 only]
















glCopyTexImage2D — copy pixels into a 2D texture image
    void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y,
        GLsizei width, GLsizei height, GLint border);

target
    Specifies the target texture (of the active texture unit)[GL ES 2.0 only]. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.

level
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

internalformat
    Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_RGB, or GL_RGBA. Limitation as per GL ES 2.0 and GL 4

x, y
    Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.

width
    Specifies the width of the texture image. (All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.)[GL ES 2.0]/(Must be 0 or 2 n + 2 ⁡ border for some integer n.)[GL 2.1]

height
    Specifies the height of the texture image. (All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.)[GL ES 2.0]/(Must be 0 or 2 m + 2 ⁡ border for some integer m.)[GL 2.1]

border
    Specifies the width of the border. Must be 0. Limitation as per GL ES 2.0 and GL 4

(Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0 only]

glCopyTexImage2D defines a two-dimensional texture image or cube-map texture image with pixels from the current (framebuffer (rather than from client memory, as is the case for glTexImage2D).)[GL ES 2.0]/(GL_READ_BUFFER)[GL 2.1, GL 4]

The screen-aligned pixel rectangle with lower left corner at (x, y) and with a width of width + 2*border and a height of height + 2*border defines the texture array at the mipmap level specified by level. internalformat specifies the internal format of the texture array.


The pixels in the rectangle are processed exactly as if (glReadPixels)[GL ES 2.0, GL 4]/(glCopyPixels)[GL 2.1] had been called (with format set to GL_RGBA)[GL ES 2.0 only], but the process stops just (after conversion of RGBA values. Subsequent processing is identical to that described for glTexImage2D, beginning with the clamping of the R, G, B, and A values to the range [0, 1] and then conversion to the texture's internal format for storage in the texel array.)[GL ES 2.0]/(before final conversion. At this point all pixel component values are clamped to the range [0, 1] and then converted to the texture's internal format for storage in the texel array.)[GL 2.1, GL 4]

(The components required for internalformat must be a subset of those present in the framebuffer's format. For example, a GL_RGBA framebuffer can be used to supply components for any internalformat. However, a GL_RGB framebuffer can only be used to supply components for GL_RGB or GL_LUMINANCE base internal format textures, not GL_ALPHA, GL_LUMINANCE_ALPHA, or GL_RGBA textures.)[GL ES 2.0 only]

Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates.

If any of the pixels within the specified rectangle (are outside the framebuffer)[GL ES 2.0]/(of the current GL_READ_BUFFER are outside the window)[GL 2.1, GL 4] associated with the current rendering context, then the values obtained for those pixels are undefined.

(When internalformat is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the glPixelMap function can be used to accomplish the conversion.)[omitted in GL ES 2.0]

Notes

(A GL implementation may choose to store the texture array at any internal resolution it chooses.)[GL ES 2.0 only]

(Texturing has no effect in color index mode.)[GL 2.1 only]

(1, 2, 3, and 4 are not accepted values for internalformat. )[GL 2.1, GL 4]

An image with height or width of 0 indicates a NULL texture.

(glCopyTexImage2D specifies a two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture. )

(When the ARB_imaging extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline. See glTexImage1D for specific details. )[GL 2.1 only]


errors:
GL_INVALID_ENUM is generated if
    - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
    - internalformat is not an accepted format. [GL ES 2.0 only]
GL_INVALID_VALUE is generated if
    - target is one of the six cube map 2D image targets and the width and height parameters are not equal. [GL ES 2.0 only]
    - level is less than 0.
    - width (or height)[GL ES 2.0 only] is less than 0 or greater than (GL_MAX_TEXTURE_SIZE when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.)[GL ES 2.0]/(2 + GL_MAX_TEXTURE_SIZE.)[GL 2.1]/(GL_MAX_TEXTURE_SIZE)[GL 4]
    - border is not 0. [GL ES 2.0, GL 4] / border is not 0 or 1. [GL 2.1]
    - non-power-of-two textures are not supported and the width or depth cannot be represented as 2 k + 2 ⁡ border for some integer k. [GL 2.1 only]
    - internalformat is not an accepted format. [GL 2.1 only]
GL_INVALID_VALUE may be generated if
    - level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE (when target is GL_TEXTURE_2D or GL_MAX_CUBE_MAP_TEXTURE_SIZE when target is not GL_TEXTURE_2D.)[GL ES 2.0]
GL_INVALID_OPERATION is generated if
    - the currently bound framebuffer's format does not contain a superset of the components required by the base format of internalformat. [GL ES 2.0 only]
    - internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth buffer. [GL 2.1, GL 4]
GL_INVALID_FRAMEBUFFER_OPERATION is generated if
    - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). [GL ES 2.0 only]

associated gets:
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0 only]
    glGetTexImage [GL 2.1, GL 4]
    glIsEnabled with argument GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP [GL 2.1 only]

















glCopyTexSubImage2D — copy a two-dimensional texture subimage
    void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y,
        GLsizei width, GLsizei height);

target:
    Specifies the target (texture (of the active texture unit)[GL ES 2.0 only].)[GL ES 2.0, GL 2.1]/(to which the texture object is bound)[GL 4] Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.

level:
    Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.

xoffset:
    Specifies a texel offset in the x direction within the texture array.

yoffset:
    Specifies a texel offset in the y direction within the texture array.

x, y:
    Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.

width:
    Specifies the width of the texture subimage.

height:
    Specifies the height of the texture subimage.

(Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is active. Texturing is active when the current fragment shader or vertex shader makes use of built-in texture lookup functions.)[GL ES 2.0 only]

glCopyTexSubImage2D replaces a rectangular portion of a two-dimensional texture image or cube-map texture image with pixels from the current (framebuffer)[GL ES 2.0]/(GL_READ_BUFFER)[GL 2.1, GL 4] (rather than from (client)[GL ES 2.0]/(main)[GL 2.1, GL 4] memory, as is the case for glTexSubImage2D).

The screen-aligned pixel rectangle with lower left corner at (x, y) and with width width and height height replaces the portion of the texture array with x indices xoffset through xoffset + width - 1 , inclusive, and y indices yoffset through yoffset + height - 1 , inclusive, at the mipmap level specified by level.

The pixels in the rectangle are processed exactly as if (glReadPixels)[GL ES 2.0, GL 4]/(glCopyPixels)[GL 2.1] had been called (with format set to GL_RGBA)[only GL ES 2.0], but the process stops just (after conversion of RGBA values. Subsequent processing is identical to that described for glTexSubImage2D, beginning with the clamping of the R, G, B, and A values to the range [0,1] and then conversion to the texture's internal format for storage in the texel array.)[GL ES 2.0]/(before final conversion. At this point, all pixel component values are clamped to the range [0,1] and then converted to the texture's internal format for storage in the texel array.)[GL 2.1, GL 4]

The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.

(When target is GL_TEXTURE_1D_ARRAY then the y coordinate and height are treated as the start slice and number of slices to modify.) [GL 4 only]

If any of the pixels within the specified rectangle (are outside the framebuffer)[GL ES 2.0]/(of the current GL_READ_BUFFER are outside the read window)[GL 2.1, GL 4] associated with the current rendering context, then the values obtained for those pixels are undefined.

No change is made to the internalformat, width, or height (or border)[only GL 2.1] parameters of the specified texture array or to texel values outside the specified subregion.


Notes

glCopyTexSubImage2D specifies the two-dimensional or cube-map texture for the current texture unit, specified with glActiveTexture. [only GL ES 2.0]

(Texturing has no effect in color index mode.

glPixelStore and glPixelTransfer modes affect texture images in exactly the way they affect glDrawPixels.

When the ARB_imaging extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline. See glTexImage1D for specific details. )[GL 2.1]

(glPixelStore modes affect texture images. )[GL 4]

errors:
    GL_INVALID_ENUM is generated if
        - target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
    GL_INVALID_VALUE is generated if
        - level is less than 0.
        - xoffset < 0 , xoffset + width > w , yoffset < 0 , or yoffset + height > h , where w is the (width)[GL ES 2.0]/(GL_TEXTURE_WIDTH)[GL 4] and h is the (height)[GL ES 2.0]/(GL_TEXTURE_HEIGHT)[GL 4] of the texture image being modified. [GL ES 2.0, GL 4]
        - width or height is less than 0.  [GL ES 2.0 only]
        - xoffset < - b , xoffset + width > w - b , yoffset < - b , or yoffset + height > h - b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the GL_TEXTURE_BORDER of the texture image being modified. Note that w and h include twice the border width. [GL 2.1 only]
        - the effective target is GL_TEXTURE_RECTANGLE and level is not zero. [GL 4 only]
    GL_INVALID_VALUE may be generated if
        - level > log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE.
    GL_INVALID_OPERATION is generated if
        - the texture array has not been defined by a previous glTexImage2D(, glTexStorage2D)[GL 4 only] or glCopyTexImage2D operation.
        - the currently bound framebuffer's format does not contain a superset of the components required by the texture's base internal format. [GL ES 2.0 only]
        (- the read buffer is GL_NONE, or
        - the value of GL_READ_FRAMEBUFFER_BINDING is non-zero, and:
            the read buffer selects an attachment that has no image attached, or
            the effective value of GL_SAMPLE_BUFFERS for the read framebuffer is one.)[GL 4 only]
    GL_INVALID_FRAMEBUFFER_OPERATION is generated if
        - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE).  [GL ES 2.0 only]
        - the object bound to GL_READ_FRAMEBUFFER_BINDING is not framebuffer complete. [GL 4]

associated gets:
    glGet with argument GL_MAX_TEXTURE_SIZE or GL_MAX_CUBE_MAP_TEXTURE_SIZE [GL ES 2.0 only]
    glGetTexImage [GL 2.1, GL 4]
    glIsEnabled with argument GL_TEXTURE_2D [GL 2.1]










glCreateProgram — create a program object
    GLuint glCreateProgram(void);

glCreateProgram creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached.

One or more executables are created in a program object by successfully attaching shader objects to it with glAttachShader, successfully compiling the shader objects with glCompileShader, and successfully linking the program object with glLinkProgram. These executables are made part of current state when glUseProgram is called. Program objects can be deleted by calling glDeleteProgram. The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.

Notes

Like (display lists and)[GL 2.1 only]/(buffer and)[GL 4 only] texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.

Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.

errors:
    This function returns 0 if an error occurs creating the program object.

associated gets:
    glGet with the argument GL_CURRENT_PROGRAM
    glGetActiveAttrib with a valid program object and the index of an active attribute variable
    glGetActiveUniform with a valid program object and the index of an active uniform variable
    glGetAttachedShaders with a valid program object
    glGetAttribLocation with a valid program object and the name of an attribute variable
    glGetProgram(iv)[GL ES 2.0] with a valid program object and the parameter to be queried
    glGetProgramInfoLog with a valid program object
    glGetUniform with a valid program object and the location of a uniform variable
    glGetUniformLocation with a valid program object and the name of a uniform variable
    glIsProgram




glCreateShader — create a shader object
    GLuint glCreateShader(GLenum shaderType);

shaderType
    Specifies the type of shader to be created. Must be either GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. Limitation as per GL ES 2.0 and GL 2.1

glCreateShader creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. shaderType indicates the type of shader to be created. Two types of shaders are supported. A shader of type GL_VERTEX_SHADER is a shader that is intended to run on the programmable vertex processor (and replace the fixed functionality vertex processing in OpenGL)[GL 2.1 only]. A shader of type GL_FRAGMENT_SHADER is a shader that is intended to run on the programmable fragment processor (and replace the fixed functionality fragment processing in OpenGL)[GL 2.1 only].

When created, a shader object's GL_SHADER_TYPE parameter is set to either GL_VERTEX_SHADER or GL_FRAGMENT_SHADER, depending on the value of shaderType.

Notes

Like (display lists and)[GL 2.1 only]/(buffer and)[GL 4 only] texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.

Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.

errors:
    This function returns 0 if an error occurs creating the shader object.
    GL_INVALID_ENUM is generated if
        - shaderType is not an accepted value.

associated gets:
    glGetShader(iv)[GL ES 2.0] with a valid shader object and the parameter to be queried
    glGetShaderInfoLog with a valid shader object
    glGetShaderSource with a valid shader object
    glIsShader








glCullFace — specify whether front- or back-facing (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] can be culled
    void glCullFace(GLenum mode);

mode
    Specifies whether front- or back-facing (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.

glCullFace specifies whether front- or back-facing (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are culled (as specified by mode) when (polygon)[GL ES 2.0]/(facet)[GL 2.1, GL 4] culling is enabled. (Polygon)[GL ES 2.0]/(Facet)[GL 2.1, GL 4] culling is initially disabled. To enable and disable (polygon)[GL ES 2.0]/(facet)[GL 2.1, GL 4] culling, call the glEnable and glDisable commands with the argument GL_CULL_FACE. (Facets include triangles, quadrilaterals, polygons, and rectangles.)[GL 2.1, GL 4]

glFrontFace specifies which of the clockwise and counterclockwise (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are front-facing and back-facing. See glFrontFace.

Notes

If mode is GL_FRONT_AND_BACK, no (polygons)[GL ES 2.0]/(facets)[GL 2.1, GL 4] are drawn, but other primitives such as points and lines are drawn.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.

associated gets:
    glIsEnabled with argument GL_CULL_FACE
    glGet with argument GL_CULL_FACE_MODE











glDeleteBuffers — delete named buffer objects
    void glDeleteBuffers(GLsizei n, const GLuint * buffers);

n
    Specifies the number of buffer objects to be deleted.

buffers
    Specifies an array of buffer objects to be deleted.

glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by glGenBuffers). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object, (which reverts to client memory usage)[omitted in GL 4]).

glDeleteBuffers silently ignores 0's and names that do not correspond to existing buffer objects.

errors:
    GL_INVALID_VALUE is generated if
        - n is negative.

associated gets:
    glIsBuffer






glDeleteProgram — delete a program object
    void glDeleteProgram(GLuint program);

program
    Specifies the program object to be deleted.

glDeleteProgram frees the memory and invalidates the name associated with the program object specified by program. This command effectively undoes the effects of a call to glCreateProgram.

If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to glDeleteShader. A value of 0 for program will be silently ignored.

To determine whether a program object has been flagged for deletion, call glGetProgram(iv)[GL ES 2.0 only] with arguments program and GL_DELETE_STATUS.

errors:
    GL_INVALID_VALUE is generated if
        - program is not a value generated by OpenGL.

associated gets:
    glGet with argument GL_CURRENT_PROGRAM
    glGetProgram(iv)[GL ES 2.0 only] with arguments program and GL_DELETE_STATUS
    glIsProgram












glDeleteShader — delete a shader object
    void glDeleteShader(GLuint shader);

shader
    Specifies the shader object to be deleted.

glDeleteShader frees the memory and invalidates the name associated with the shader object specified by shader. This command effectively undoes the effects of a call to glCreateShader.

If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for shader will be silently ignored.

To determine whether an object has been flagged for deletion, call glGetShader(iv)[GL ES 2.0 only] with arguments shader and GL_DELETE_STATUS.

errors:
    GL_INVALID_VALUE is generated if
        - shader is not a value generated by OpenGL.

associated gets:
    glGetAttachedShaders with the program object to be queried
    glGetShader(iv)[GL ES 2.0 only] with arguments shader and GL_DELETE_STATUS
    glIsShader















glDeleteTextures — delete named textures
    void glDeleteTextures(GLsizei n, const GLuint * textures);

n
    Specifies the number of textures to be deleted.

textures
    Specifies an array of textures to be deleted.

glDeleteTextures deletes n textures named by the elements of the array textures. After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by glGenTextures). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture).

glDeleteTextures silently ignores 0's and names that do not correspond to existing textures.

errors:
    GL_INVALID_VALUE is generated if
        - n is negative.

associated gets:
    glIsTexture









glDepthFunc — specify the value used for depth buffer comparisons
    void glDepthFunc(GLenum func);

func
    Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.

glDepthFunc specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See glEnable and glDisable of GL_DEPTH_TEST.)

func specifies the conditions under which the pixel will be drawn. The comparison functions are as follows:

GL_NEVER
    Never passes.

GL_LESS
    Passes if the incoming depth value is less than the stored depth value.

GL_EQUAL
    Passes if the incoming depth value is equal to the stored depth value.

GL_LEQUAL
    Passes if the incoming depth value is less than or equal to the stored depth value.

GL_GREATER
    Passes if the incoming depth value is greater than the stored depth value.

GL_NOTEQUAL
    Passes if the incoming depth value is not equal to the stored depth value.

GL_GEQUAL
    Passes if the incoming depth value is greater than or equal to the stored depth value.

GL_ALWAYS
    Always passes.

The initial value of func is GL_LESS. Initially, depth testing is disabled. If depth testing is disabled or (if)[omitted in GL ES 2.0] no depth buffer exists, it is as if the depth test always passes.

Notes

Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. (In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS.)[GL 4 only]

errors:
    GL_INVALID_ENUM is generated if
        - func is not an accepted value.

associated gets:
    glGet with argument GL_DEPTH_FUNC
    glIsEnabled with argument GL_DEPTH_TEST














glDepthMask — enable or disable writing into the depth buffer
    void glDepthMask(GLboolean flag);

flag
    Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.

glDepthMask specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.

Notes

Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to GL_ALWAYS (see glDepthFunc). [GL 4 only]

associated gets:
    glGet with argument GL_DEPTH_WRITEMASK










glDepthRange[f] — specify mapping of depth values from normalized device coordinates to window coordinates
    void glDepthRangef(GLclampf nearVal, GLclampf farVal); [GL ES 2.0]
    void glDepthRangef(GLfloat nearVal, GLfloat farVal); [GL 4]
    void glDepthRange(GLclampd nearVal, GLclampd farVal); [GL 2.1]
    void glDepthRange(GLdouble nearVal, GLdouble farVal); [GL 4]

nearVal
    Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.

farVal
    Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.

After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. glDepthRange[f] specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by glDepthRange[f] are both clamped to this range before they are accepted.

The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.

Notes

It is not necessary that nearVal be less than farVal. Reverse mappings such as nearVal = 1 , and farVal = 0 are acceptable.

The type of the nearVal and farVal parameters was changed from GLclampf to GLfloat for glDepthRangef and from GLclampd to GLdouble for glDepthRange. This change is transparent to user code and is described in detail on the removedTypes page. [GL 4 only]

associated gets:
    glGet with argument GL_DEPTH_RANGE
















glDetachShader — detach a shader object from a program object (to which it is attached)[GL 2.1, GL 4]
    void glDetachShader(GLuint program, GLuint shader);

program
    Specifies the program object from which to detach the shader object.

shader
    Specifies the shader object to be detached.

glDetachShader detaches the shader object specified by shader from the program object specified by program. This command can be used to undo the effect of the command glAttachShader.

If shader has already been flagged for deletion by a call to glDeleteShader and it is not attached to any other program object, it will be deleted after it has been detached.

errors:
    GL_INVALID_VALUE is generated if
        - either program or shader is a value that was not generated by OpenGL.
    GL_INVALID_OPERATION is generated if
        - program is not a program object.
        - shader is not a shader object.
        - shader is not attached to program.

associated gets:
    glGetAttachedShaders with the handle of a valid program object
    glGetShader(iv)[GL ES 2.0 only] with arguments shader and GL_DELETE_STATUS
    glIsProgram
    glIsShader














glEnable — enable or disable server-side GL capabilities
    void glEnable(GLenum cap);
    void glDisable(GLenum cap);

cap:
    Specifies a symbolic constant indicating a GL capability.

glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to determine the current setting of any capability. The initial value for each capability with the exception of GL_DITHER is GL_FALSE. The initial value for GL_DITHER is GL_TRUE.

Both glEnable and glDisable take a single argument, cap, which can assume one of the following values: (Limitation as per GL ES 2.0)

GL_BLEND
    If enabled, blend the computed fragment color values with the values in the color buffers. See glBlendFunc.

GL_CULL_FACE
    If enabled, cull polygons based on their winding in window coordinates. See glCullFace.

GL_DEPTH_TEST
    If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See glDepthFunc and glDepthRangef.

GL_DITHER
    If enabled, dither color components or indices before they are written to the color buffer.

GL_POLYGON_OFFSET_FILL
    If enabled, (and if the polygon is rendered in GL_FILL mode ,)[GL 2.1, GL 4] an offset is added to depth values of a polygon's fragments (produced by rasterization)[GL ES 2.0]/(before the depth comparison is performed)[GL 2.1, GL 4]. See glPolygonOffset.

GL_SAMPLE_ALPHA_TO_COVERAGE
    If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.

GL_SAMPLE_COVERAGE
    If enabled, the fragment's coverage is ANDed with the temporary coverage value. If GL_SAMPLE_COVERAGE_INVERT is set to GL_TRUE, invert the coverage value. See glSampleCoverage.

GL_SCISSOR_TEST
    If enabled, discard fragments that are outside the scissor rectangle. See glScissor.

GL_STENCIL_TEST
    If enabled, do stencil testing and update the stencil buffer. See glStencilFunc and glStencilOp.

errors:
    GL_INVALID_ENUM is generated if
        - cap is not one of the values listed previously.

associated gets:
    glIsEnabled
    glGet











glEnableVertexAttribArray — enable or disable a generic vertex attribute array
    void glEnableVertexAttribArray(GLuint index);
    void glDisableVertexAttribArray(GLuint index);

index:
    Specifies the index of the generic vertex attribute to be enabled or disabled.

glEnableVertexAttribArray enables the generic vertex attribute array specified by index. glDisableVertexAttribArray disables the generic vertex attribute array specified by index. (glEnableVertexAttribArray uses currently bound vertex array object for the operation. glDisableVertexAttribArray disables the generic vertex attribute array specified by index. glDisableVertexAttribArray uses currently bound vertex array object for the operation,)[GL 4 only] By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as glDrawArrays or glDrawElements.

errors:
    GL_INVALID_VALUE is generated if
        - index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
    GL_INVALID_OPERATION is generated if
        - no vertex array object is bound. [GL 4 only]

associated gets:
    glGet with argument GL_MAX_VERTEX_ATTRIBS
    glGetVertexAttrib with arguments index and GL_VERTEX_ATTRIB_ARRAY_ENABLED
    glGetVertexAttribPointerv with arguments index and GL_VERTEX_ATTRIB_ARRAY_POINTER











glDrawArrays — render primitives from array data
    void glDrawArrays(GLenum mode, GLint first, GLsizei count);

mode
    Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, and GL_TRIANGLES are accepted. Limitation as per GL ES 2.0

first
    Specifies the starting index in the enabled arrays.

count
    Specifies the number of indices to be rendered.

glDrawArrays specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual (vertex attribute, you can use glVertexAttribPointer to)[GL ES 2.0]/(vertex, normal, texture coordinate, edge flag, or color, you can)[GL 2.1, GL 4] prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to glDrawArrays.

When glDrawArrays is called, it uses count sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element first. mode specifies what kind of primitives are constructed and how the array elements construct those primitives. (If GL_VERTEX_ARRAY is not enabled, no geometric primitives are generated.)[GL 2.1 only]

To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and glDisableVertexAttribArray. [GL ES 2.0 only]

Vertex attributes that are modified by glDrawArrays have an unspecified value after glDrawArrays returns. (For example, if GL_COLOR_ARRAY is enabled, the value of the current color is undefined after glDrawArrays executes.)[GL 2.1 only] Attributes that aren't modified remain well defined. [GL 2.1, GL 4]

Notes

If the current program object, as set by glUseProgram, is invalid, rendering results are undefined. However, no error is generated for this case. [GL ES 2.0 only]

glDrawArrays is included in display lists. If glDrawArrays is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed. [GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.
    GL_INVALID_VALUE is generated if
        - count is negative.
    GL_INVALID_OPERATION is generated if
        - a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. [GL 4 only]
    GL_INVALID_FRAMEBUFFER_OPERATION is generated if
        - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). [GL ES 2.0 only]





glDrawElements — render primitives from array data
    void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices);

mode
    Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, and GL_TRIANGLES are accepted. Limitation as per GL ES 2.0

count
    Specifies the number of elements to be rendered.

type
    Specifies the type of the values in indices. Must be GL_UNSIGNED_BYTE or GL_UNSIGNED_SHORT. Limitation as per GL ES 2.0

indices
    Specifies a pointer to the location where the indices are stored.

glDrawElements specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each (vertex attribute, you can use glVertexAttribPointer to prespecify separate arrays of vertex attributes)[GL ES 2.0]/(individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on,)[GL 2.1, GL 4] and use them to construct a sequence of primitives with a single call to glDrawElements.

When glDrawElements is called, it uses count sequential elements from an enabled array, starting at indices to construct a sequence of geometric primitives. mode specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used. (If GL_VERTEX_ARRAY is not enabled, no geometric primitives are constructed.)[GL 2.1 only]

To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and glDisableVertexAttribArray. [GL ES 2.0 only]

Vertex attributes that are modified by glDrawElements have an unspecified value after glDrawElements returns. (For example, if GL_COLOR_ARRAY is enabled, the value of the current color is undefined after glDrawElements executes.)[GL 2.1 only] Attributes that aren't modified maintain their previous values. [GL 2.1, GL 4]

Notes

If the current program object, as set by glUseProgram, is invalid, rendering results are undefined. However, no error is generated for this case. [GL ES 2.0 only]

glDrawElements is included in display lists. If glDrawElements is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed. [GL 2.1 only]

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.
        - type is not GL_UNSIGNED_BYTE or GL_UNSIGNED_SHORT. [GL ES 2.0 only]
    GL_INVALID_VALUE is generated if
        - count is negative.
    GL_INVALID_OPERATION is generated if
        - a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. [GL 2.1, GL 4]
        - a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. [GL 4 only]
    GL_INVALID_FRAMEBUFFER_OPERATION is generated if
        - the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). [GL ES 2.0 only]








glFinish — block until all GL execution is complete
    void glFinish(void);

glFinish does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.

Notes

glFinish requires a round trip to the server.





glFlush — force execution of GL commands in finite time
    void glFlush(void);

Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. glFlush empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time.

Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call glFlush whenever they count on having all of their previously issued commands completed. For example, call glFlush before waiting for user input that depends on the generated image.

Notes

glFlush can return at any time. It does not wait until the execution of all previously issued GL commands is complete.





glFrontFace — define front- and back-facing polygons
    void glFrontFace(GLenum mode);

mode
    Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.

In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call glEnable and glDisable with argument GL_CULL_FACE.

The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. glFrontFace specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing GL_CCW to mode selects counterclockwise polygons as front-facing; GL_CW selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.

errors:
    GL_INVALID_ENUM is generated if
        - mode is not an accepted value.

associated gets:
    glGet with argument GL_FRONT_FACE






